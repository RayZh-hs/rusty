package rusty.parser

// This file is generated by GPT-5, Agent Mode
// Rewritten to use the Visitor pattern

import rusty.parser.nodes.*
import rusty.parser.nodes.support.*
import rusty.parser.nodes.utils.Visitor
import rusty.parser.nodes.utils.accept
import java.io.File

fun Parser.Companion.dump(output: ASTTree, outputPath: String) =
    File(outputPath).writeText(formatAST(output, color = false))

fun Parser.Companion.dumpScreen(output: ASTTree) {
    println(colorizeStatic("[rusty] Parser dump:", 32))
    print(formatAST(output, color = true))
    println()
}

// ----- Pretty printer (Visitor based) -----
private data class RenderConfig(val color: Boolean)

private fun formatAST(root: ASTTree, color: Boolean): String {
    val visitor = DumpVisitor(RenderConfig(color))
    root.accept(visitor)
    return visitor.sb.toString()
}

// ----- Visitor implementation -----
// Basic ANSI color wrapper (avoids external dependency & reflection issues)
private fun colorizeStatic(text: String, code: Int, enable: Boolean = true): String =
    if (enable) "\u001B[${code}m$text\u001B[0m" else text

private class DumpVisitor(private val cfg: RenderConfig) : Visitor<Unit> {
    val sb = StringBuilder()
    private var indent = 0

    // region small utils
    private fun line(text: String) { sb.append("  ".repeat(indent)).appendLine(text) }
    private inline fun <T> indented(block: () -> T): T { indent++; return try { block() } finally { indent-- } }

    private fun label(text: String) = color(text, 36)
    private fun field(text: String) = color(text, 90)
    private fun value(text: String) = color(text, 32)
    private fun number(text: String) = color(text, 34)
    private fun literal(text: String) = color(text, 33)
    private fun keyword(text: String) = color(text, 35)
    private fun op(text: String) = color(text, 31)
    private fun info(text: String) = color(text, 90)

    private fun color(text: String, code: Int): String = if (cfg.color) "\u001B[${code}m$text\u001B[0m" else text
    // endregion

    // region support printers (unchanged logic)
    private fun appendCondition(cond: ConditionsNode) {
        line(label("Condition"))
        indented { cond.expression.accept(this) }
    }
    private fun appendIfBranch(br: IfBranchNode) {
        line(label("IfBranch"))
        indented {
            line(field("cond") + ":")
            indented { appendCondition(br.condition) }
            line(field("then") + ":")
            indented { br.then.accept(this) }
        }
    }
    private fun appendPattern(pat: PatternNode) {
        val alts = pat.patternNodes
        if (alts.size == 1) {
            appendSupportingPattern(alts[0])
        } else {
            line(label("Pattern(|)"))
            indented {
                alts.forEachIndexed { i, p ->
                    line(field("[$i]") + ":")
                    indented { appendSupportingPattern(p) }
                }
            }
        }
    }
    private fun appendSupportingPattern(p: SupportingPatternNode) {
        when (p) {
            is SupportingPatternNode.LiteralPatternNode -> {
                val neg = if (p.isNegated) " " + op("-") else ""
                line(label("PatLiteral") + neg)
                indented { p.literalNode.accept(this) }
            }
            is SupportingPatternNode.IdentifierPatternNode -> {
                val mods = buildList {
                    if (p.isRef) add(keyword("ref"))
                    if (p.isMut) add(keyword("mut"))
                }.joinToString(" ")
                val head = listOf(label("PatIdent"), mods, value(p.identifier))
                    .filter { it.isNotEmpty() }
                    .joinToString(" ")
                line(head)
                p.extendedByPatternNode?.let { sub ->
                    indented {
                        line(field("sub") + ":")
                        indented { appendPattern(sub) }
                    }
                }
            }
            is SupportingPatternNode.WildcardPatternNode -> line(label("PatWildcard"))
            is SupportingPatternNode.DestructuredTuplePatternNode -> {
                line(label("PatTuple"))
                indented {
                    p.tuple.forEachIndexed { i, inner ->
                        line(field("[$i]") + ":")
                        indented { appendSupportingPattern(inner) }
                    }
                }
            }
            is SupportingPatternNode.PathPatternNode -> {
                val pathStr = p.path.path.joinToString("::") { seg -> seg.name ?: seg.token.toString().lowercase() }
                line(label("PatPath") + " " + value(pathStr))
            }
        }
    }
    private fun appendType(type: TypeNode) {
        when (type) {
            is TypeNode.TypePath -> {
                val seg = type.pathSegmentNode
                line(value(seg.name ?: seg.token.toString().lowercase()))
            }
            is TypeNode.NeverType -> {
                line(label("Never"))
                indented { appendType(type.type) }
            }
            is TypeNode.TupleType -> {
                line(label("TupleType"))
                indented {
                    if (type.types.isEmpty()) line(info("(unit)")) else type.types.forEachIndexed { i, t ->
                        line(field("[$i]") + ":")
                        indented { appendType(t) }
                    }
                }
            }
            is TypeNode.ArrayType -> {
                line(label("ArrayType"))
                indented {
                    line(field("elem") + ":")
                    indented { appendType(type.type) }
                    line(field("len") + ":")
                    indented { type.length.accept(this) }
                }
            }
            is TypeNode.SliceType -> {
                line(label("SliceType"))
                indented { appendType(type.type) }
            }
            is TypeNode.ReferenceType -> {
                val mutPart = if (type.isMut) " mut" else ""
                line(label("RefType$mutPart"))
                indented { appendType(type.type) }
            }
            is TypeNode.InferredType -> line(label("InferredType"))
        }
    }
    private fun appendGenericParams(params: ParamsNode.GenericParamsNode) {
        if (params.genericParams.isEmpty()) line(info("(none)")) else params.genericParams.forEachIndexed { i, gp ->
            line(field("[$i]") + ":")
            indented { appendType(gp.type) }
        }
    }
    private fun appendFunctionParams(params: ParamsNode.FunctionParamsNode) {
        params.selfParam?.let { sp ->
            line(field("self") + ":")
            indented { appendSelfParam(sp) }
        }
        if (params.functionParams.isEmpty()) return
        line(field("args") + ":")
        indented {
            params.functionParams.forEachIndexed { i, fn ->
                line(field("[$i]") + ":")
                indented { appendFunctionParam(fn) }
            }
        }
    }
    private fun appendSelfParam(sp: SelfParamNode) {
        val mods = buildList { if (sp.isReference) add("&"); if (sp.isMutable) add(keyword("mut")) }.joinToString("")
        line(value("self") + if (mods.isNotEmpty()) " <$mods>" else "")
        sp.type?.let {
            line(field("type") + ":")
            indented { appendType(it) }
        }
    }
    private fun appendFunctionParam(param: FunctionParamNode) {
        when (param) {
            is FunctionParamNode.FunctionParamTypedPatternNode -> {
                line(label("ParamPattern"))
                indented {
                    line(field("pattern") + ":")
                    indented { appendPattern(param.pattern) }
                    param.type?.let {
                        line(field("type") + ":")
                        indented { appendType(it) }
                    }
                }
            }
            is FunctionParamNode.FunctionParamTypeNode -> {
                line(label("ParamType"))
                indented { appendType(param.type) }
            }
            FunctionParamNode.FunctionParamWildcardNode -> line(label("ParamWildcard..."))
        }
    }
    private fun appendStructField(structField: StructFieldNode) {
        line(field("name") + ": " + value(structField.identifier))
        line(field("type") + ":")
        indented { appendType(structField.typeNode) }
    }
    private fun appendEnumVariant(variant: EnumVariantNode) { line(value(variant.identifier)) }
    private fun appendAssociatedItems(ai: AssociatedItemsNode) {
        if (ai.constItems.isEmpty() && ai.functionItems.isEmpty()) {
            line(info("(none)"))
            return
        }
        if (ai.constItems.isNotEmpty()) {
            line(field("consts") + ":")
            indented { ai.constItems.forEachIndexed { i, c -> line(field("[$i]") + ":"); indented { c.accept(this) } } }
        }
        if (ai.functionItems.isNotEmpty()) {
            line(field("fns") + ":")
            indented { ai.functionItems.forEachIndexed { i, f -> line(field("[$i]") + ":"); indented { f.accept(this) } } }
        }
    }
    // endregion

    // region Visitor methods
    override fun visitCrate(node: CrateNode) {
        line(label("Crate"))
        indented {
            if (node.items.isEmpty()) line(info("(empty)")) else node.items.forEach { it.accept(this) }
        }
    }
    override fun visitPattern(node: PatternNode) = appendPattern(node)
    override fun visitLiteralPattern(node: SupportingPatternNode.LiteralPatternNode) = appendSupportingPattern(node)
    override fun visitIdentifierPattern(node: SupportingPatternNode.IdentifierPatternNode) = appendSupportingPattern(node)
    override fun visitWildcardPattern(node: SupportingPatternNode.WildcardPatternNode) = appendSupportingPattern(node)
    override fun visitDestructuredTuplePattern(node: SupportingPatternNode.DestructuredTuplePatternNode) = appendSupportingPattern(node)
    override fun visitPathPattern(node: SupportingPatternNode.PathPatternNode) = appendSupportingPattern(node)

    override fun visitBlockExpression(node: ExpressionNode.WithBlockExpressionNode.BlockExpressionNode) {
        line(label("Block"))
        indented {
            val hasStmts = node.statements.isNotEmpty()
            val hasTail = node.trailingExpression != null
            if (!hasStmts && !hasTail) line(info("(empty)")) else {
                node.statements.forEach { it.accept(this) }
                if (hasTail) {
                    line(field("trailing") + ":")
                    indented { node.trailingExpression!!.accept(this) }
                }
            }
        }
    }
    override fun visitConstBlockExpression(node: ExpressionNode.WithBlockExpressionNode.ConstBlockExpressionNode) {
        line(label("ConstBlock"))
        indented { node.expression.accept(this) }
    }
    override fun visitLoopBlockExpression(node: ExpressionNode.WithBlockExpressionNode.LoopBlockExpressionNode) {
        line(label("LoopBlock"))
        indented { node.expression.accept(this) }
    }
    override fun visitWhileBlockExpression(node: ExpressionNode.WithBlockExpressionNode.WhileBlockExpressionNode) {
        line(label("WhileBlock"))
        indented {
            line(field("condition") + ":")
            indented { appendCondition(node.condition) }
            line(field("body") + ":")
            indented { node.expression.accept(this) }
        }
    }
    override fun visitIfBlockExpression(node: ExpressionNode.WithBlockExpressionNode.IfBlockExpressionNode) {
        line(label("IfBlock"))
        indented {
            node.ifs.forEachIndexed { idx, br ->
                line(field("if[$idx]") + ":")
                indented { appendIfBranch(br) }
            }
            node.elseBranch?.let { eb ->
                line(field("else") + ":")
                indented { eb.accept(this) }
            }
        }
    }
    override fun visitMatchBlockExpression(node: ExpressionNode.WithBlockExpressionNode.MatchBlockExpressionNode) {
        line(label("MatchBlock"))
        indented {
            line(field("scrutinee") + ":")
            indented { node.scrutinee.accept(this) }
            line(field("arms") + ":")
            indented {
                val arms = node.matchArmsNode.arms
                val values = node.matchArmsNode.values
                for (i in arms.indices) {
                    line(field("[$i]") + ":")
                    indented {
                        line(field("pattern") + ":")
                        indented { appendPattern(arms[i].pattern) }
                        arms[i].guard?.let { g ->
                            line(field("guard") + ":")
                            indented { g.accept(this) }
                        }
                        line(field("value") + ":")
                        indented { values[i].accept(this) }
                    }
                }
            }
        }
    }
    override fun visitI32Literal(node: ExpressionNode.WithoutBlockExpressionNode.LiteralExpressionNode.I32LiteralNode) =
        line(label("I32") + " " + literal(node.value.toString()))
    override fun visitISizeLiteral(node: ExpressionNode.WithoutBlockExpressionNode.LiteralExpressionNode.ISizeLiteralNode) =
        line(label("ISize") + " " + literal(node.value.toString()))
    override fun visitU32Literal(node: ExpressionNode.WithoutBlockExpressionNode.LiteralExpressionNode.U32LiteralNode) =
        line(label("U32") + " " + literal(node.value.toString()))
    override fun visitUSizeLiteral(node: ExpressionNode.WithoutBlockExpressionNode.LiteralExpressionNode.USizeLiteralNode) =
        line(label("USize") + " " + literal(node.value.toString()))
    override fun visitStringLiteral(node: ExpressionNode.WithoutBlockExpressionNode.LiteralExpressionNode.StringLiteralNode) =
        line(label("String") + " " + literal("\"${node.value}\""))
    override fun visitCharLiteral(node: ExpressionNode.WithoutBlockExpressionNode.LiteralExpressionNode.CharLiteralNode) =
        line(label("Char") + " " + literal("'${node.value}'"))
    override fun visitBoolLiteral(node: ExpressionNode.WithoutBlockExpressionNode.LiteralExpressionNode.BoolLiteralNode) =
        line(label("Bool") + " " + literal(node.value.toString()))
    override fun visitUnderscoreExpression(node: ExpressionNode.WithoutBlockExpressionNode.UnderscoreExpressionNode) =
        line(literal("_"))
    override fun visitTupleExpression(node: ExpressionNode.WithoutBlockExpressionNode.TupleExpressionNode) {
        line(label("Tuple"))
        indented { node.elements.forEachIndexed { i, e -> line(field("[$i]") + ":"); indented { e.accept(this) } } }
    }
    override fun visitArrayExpression(node: ExpressionNode.WithoutBlockExpressionNode.ArrayExpressionNode) {
        line(label("Array"))
        indented {
            node.elements.forEachIndexed { i, e -> line(field("[$i]") + ":"); indented { e.accept(this) } }
            line(field("repeat") + ":")
            indented { node.repeat.accept(this) }
        }
    }
    override fun visitStructExpression(node: ExpressionNode.WithoutBlockExpressionNode.StructExpressionNode) {
        val pathStr = node.pathInExpressionNode.path.joinToString("::") { seg -> seg.name ?: seg.token.toString().lowercase() }
        line(label("StructExpr") + " " + value(pathStr))
        indented {
            if (node.fields.isEmpty()) line(info("(no fields)")) else node.fields.forEachIndexed { i, f ->
                line(field("[$i]") + ":")
                indented {
                    line(field("name") + ": " + value(f.identifier))
                    if (f.expressionNode != null) {
                        line(field("value") + ":")
                        indented { f.expressionNode.accept(this) }
                    } else line(info("(no value)"))
                }
            }
        }
    }
    override fun visitCallExpression(node: ExpressionNode.WithoutBlockExpressionNode.CallExpressionNode) {
        line(label("Call"))
        indented {
            line(field("callee") + ":")
            indented { node.callee.accept(this) }
            if (node.arguments.isNotEmpty()) {
                line(field("args") + ":")
                indented { node.arguments.forEachIndexed { i, a -> line(field("[$i]") + ":"); indented { a.accept(this) } } }
            }
        }
    }
    override fun visitIndexExpression(node: ExpressionNode.WithoutBlockExpressionNode.IndexExpressionNode) {
        line(label("Index"))
        indented {
            line(field("base") + ":")
            indented { node.base.accept(this) }
            line(field("index") + ":")
            indented { node.index.accept(this) }
        }
    }
    override fun visitFieldExpression(node: ExpressionNode.WithoutBlockExpressionNode.FieldExpressionNode) {
        line(label("Field"))
        indented {
            line(field("base") + ":")
            indented { node.base.accept(this) }
            line(field("name") + ": " + value(node.field))
        }
    }
    override fun visitPathExpression(node: ExpressionNode.WithoutBlockExpressionNode.PathExpressionNode) {
        val pathStr = node.pathInExpressionNode.path.joinToString("::") { seg -> seg.name ?: seg.token.toString().lowercase() }
        line(label("Path") + " " + value(pathStr))
    }
    override fun visitTupleIndexing(node: ExpressionNode.WithoutBlockExpressionNode.TupleIndexingNode) {
        line(label("TupleIndex"))
        indented {
            line(field("base") + ":")
            indented { node.base.accept(this) }
            line(field("index") + ": " + number(node.index.toString()))
        }
    }
    override fun visitInfixOperator(node: ExpressionNode.WithoutBlockExpressionNode.InfixOperatorNode) {
        line(label("Infix") + " op=" + op(node.op.toString()))
        indented {
            line(field("left") + ":")
            indented { node.left.accept(this) }
            line(field("right") + ":")
            indented { node.right.accept(this) }
        }
    }
    override fun visitPrefixOperator(node: ExpressionNode.WithoutBlockExpressionNode.PrefixOperatorNode) {
        line(label("Prefix") + " op=" + op(node.op.toString()))
        indented {
            line(field("expr") + ":")
            indented { node.expr.accept(this) }
        }
    }
    override fun visitReturnExpression(node: ExpressionNode.WithoutBlockExpressionNode.ControlFlowExpressionNode.ReturnExpressionNode) {
        line(keyword("return"))
        node.expr?.let {
            indented {
                line(field("value") + ":")
                indented { it.accept(this) }
            }
        }
    }
    override fun visitBreakExpression(node: ExpressionNode.WithoutBlockExpressionNode.ControlFlowExpressionNode.BreakExpressionNode) {
        line(keyword("break"))
        node.expr?.let {
            indented {
                line(field("value") + ":")
                indented { it.accept(this) }
            }
        }
    }
    override fun visitContinueExpression(node: ExpressionNode.WithoutBlockExpressionNode.ControlFlowExpressionNode.ContinueExpressionNode) =
        line(keyword("continue"))

    override fun visitNullStatement(node: StatementNode.NullStatementNode) = line(label("NullStatement"))
    override fun visitItemStatement(node: StatementNode.ItemStatementNode) {
        line(label("ItemStatement"))
        indented { node.item.accept(this) }
    }
    override fun visitLetStatement(node: StatementNode.LetStatementNode) {
        line(label("LetStatement"))
        indented {
            line(field("pattern") + ":")
            indented { appendPattern(node.patternNode) }
            node.typeNode?.let {
                line(field("type") + ":")
                indented { appendType(it) }
            }
            line(field("init") + ":")
            indented {
                if (node.expressionNode != null) node.expressionNode.accept(this) else line(info("(uninitialized)"))
            }
        }
    }
    override fun visitExpressionStatement(node: StatementNode.ExpressionStatementNode) {
        line(label("ExpressionStatement"))
        indented { node.expression.accept(this) }
    }

    override fun visitFunctionItem(node: ItemNode.FunctionItemNode) {
        line(label("FunctionItem"))
        indented {
            line(field("name") + ": " + value(node.identifier))
            node.genericParamsNode?.let {
                line(field("generics") + ":")
                indented { appendGenericParams(it) }
            }
            node.functionParamsNode?.let {
                line(field("params") + ":")
                indented { appendFunctionParams(it) }
            }
            node.returnTypeNode?.let {
                line(field("return") + ":")
                indented { appendType(it) }
            }
            node.withBlockExpressionNode?.let {
                line(field("body") + ":")
                indented { it.accept(this) }
            }
        }
    }
    override fun visitStructItem(node: ItemNode.StructItemNode) {
        line(label("StructItem"))
        indented {
            line(field("name") + ": " + value(node.identifier))
            line(field("fields") + ":")
            indented {
                if (node.fields.isEmpty()) line(info("(none)")) else node.fields.forEachIndexed { i, f ->
                    line(field("[$i]") + ":")
                    indented { appendStructField(f) }
                }
            }
            if (node.isDeclaration) line(field("decl") + ": " + info("true"))
        }
    }
    override fun visitEnumItem(node: ItemNode.EnumItemNode) {
        line(label("EnumItem"))
        indented {
            line(field("name") + ": " + value(node.identifier))
            line(field("variants") + ":")
            indented {
                if (node.variants.isEmpty()) line(info("(none)")) else node.variants.forEachIndexed { i, v ->
                    line(field("[$i]") + ":")
                    indented { appendEnumVariant(v) }
                }
            }
        }
    }
    override fun visitConstItem(node: ItemNode.ConstItemNode) {
        line(label("ConstItem"))
        indented {
            line(field("name") + ": " + value(node.identifier))
            line(field("type") + ":")
            indented { appendType(node.typeNode) }
            line(field("value") + ":")
            indented { node.expressionNode?.accept(this) ?: line(info("(none)")) }
        }
    }
    override fun visitTraitItem(node: ItemNode.TraitItemNode) {
        line(label("TraitItem"))
        indented {
            line(field("name") + ": " + value(node.identifier))
            line(field("assoc") + ":")
            indented { appendAssociatedItems(node.associatedItems) }
        }
    }
    override fun visitInherentImplItem(node: ItemNode.ImplItemNode.InherentImplItemNode) {
        line(label("ImplItem(Inherent)"))
        indented {
            line(field("type") + ":")
            indented { appendType(node.typeNode) }
            line(field("assoc") + ":")
            indented { appendAssociatedItems(node.associatedItems) }
        }
    }
    override fun visitTraitImplItem(node: ItemNode.ImplItemNode.TraitImplItemNode) {
        line(label("ImplItem(Trait)"))
        indented {
            line(field("trait") + ": " + value(node.identifier))
            line(field("type") + ":")
            indented { appendType(node.typeNode) }
            line(field("assoc") + ":")
            indented { appendAssociatedItems(node.associatedItems) }
        }
    }
    override fun visitTypePath(node: TypeNode.TypePath) = appendType(node)
    override fun visitNeverType(node: TypeNode.NeverType) = appendType(node)
    override fun visitTupleType(node: TypeNode.TupleType) = appendType(node)
    override fun visitArrayType(node: TypeNode.ArrayType) = appendType(node)
    override fun visitSliceType(node: TypeNode.SliceType) = appendType(node)
    override fun visitReferenceType(node: TypeNode.ReferenceType) = appendType(node)
    override fun visitInferredType(node: TypeNode.InferredType) = appendType(node)
    override fun visitGenericParams(node: ParamsNode.GenericParamsNode) = appendGenericParams(node)
    override fun visitFunctionParams(node: ParamsNode.FunctionParamsNode) = appendFunctionParams(node)
    override fun visitPathIndentSegment(node: PathIndentSegmentNode) { line(value(node.name ?: node.token.toString().lowercase())) }
    override fun visitPathInExpression(node: PathInExpressionNode) {
        val pathStr = node.path.joinToString("::") { it.name ?: it.token.toString().lowercase() }
        line(label("Path") + " " + value(pathStr))
    }
    // endregion
}