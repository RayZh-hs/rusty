package rusty.parser

// This dumper is generated by GPT-5, to facilitate debugging and visualization of the AST.

import com.andreapivetta.kolor.*
import rusty.parser.nodes.ExpressionNode
import rusty.parser.nodes.ItemNode
import rusty.parser.nodes.StatementNode
import rusty.parser.nodes.support.ConditionsNode
import rusty.parser.nodes.support.IfBranchNode
import rusty.parser.nodes.PatternNode
import rusty.parser.nodes.SupportingPatternNode
import rusty.parser.nodes.TypeNode
import rusty.parser.nodes.support.TypePathSegment
import rusty.parser.nodes.support.GenericArgsNode
import java.io.File

fun Parser.Companion.dump(output: ASTTree, outputPath: String) {
    val file = File(outputPath)
    file.writeText(formatAST(output, color = false))
}

fun Parser.Companion.dumpScreen(output: ASTTree) {
    println("[rusty] Parser dump:".green())
    println(formatAST(output, color = true))
    println()
}

// ----- Pretty printer -----
private data class RenderConfig(val color: Boolean)

private fun formatAST(root: ASTTree, color: Boolean): String = buildString {
    val cfg = RenderConfig(color)
    appendCrate(root, 0, cfg)
}

private fun String.cyanIf(b: Boolean) = if (b) this.cyan() else this
private fun String.grayIf(b: Boolean) = if (b) this.lightGray() else this
private fun String.greenIf(b: Boolean) = if (b) this.green() else this
private fun String.magentaIf(b: Boolean) = if (b) this.magenta() else this
private fun String.yellowIf(b: Boolean) = if (b) this.yellow() else this
private fun String.blueIf(b: Boolean) = if (b) this.blue() else this
private fun String.redIf(b: Boolean) = if (b) this.red() else this

private fun StringBuilder.line(indent: Int, text: String) {
    append("  ".repeat(indent)).appendLine(text)
}

// Root
private fun StringBuilder.appendCrate(crate: ASTTree, indent: Int, cfg: RenderConfig) {
    line(indent, label("Crate", cfg))
    if (crate.items.isEmpty()) {
        line(indent + 1, info("(empty)", cfg))
    } else {
        crate.items.forEach { appendItem(it, indent + 1, cfg) }
    }
}

// Items
private fun StringBuilder.appendItem(item: ItemNode, indent: Int, cfg: RenderConfig) {
    when (item) {
        is ItemNode.FunctionItemNode -> {
            line(indent, label("FunctionItem", cfg))
            line(indent + 1, field("name", cfg) + ": " + value(item.identifier, cfg))
            if (item.genericParamsNode != null) {
                line(indent + 1, field("generics", cfg) + ": " + info("present", cfg))
            }
            if (item.functionParamsNode != null) {
                line(indent + 1, field("params", cfg) + ": " + info("present", cfg))
            }
            item.returnTypeNode?.let {
                line(indent + 1, field("return", cfg) + ":")
                appendType(it, indent + 2, cfg)
            }
            item.withBlockExpressionNode?.let { body ->
                line(indent + 1, field("body", cfg) + ":")
                appendExpr(body, indent + 2, cfg)
            }
        }
    }
}

// Statements
private fun StringBuilder.appendStmt(stmt: StatementNode, indent: Int, cfg: RenderConfig) {
    when (stmt) {
        is StatementNode.NullStatementNode -> line(indent, label("NullStatement", cfg) + " " + keyword(";", cfg))
        is StatementNode.ItemStatementNode -> {
            line(indent, label("ItemStatement", cfg))
            appendItem(stmt.item, indent + 1, cfg)
        }
        is StatementNode.LetStatementNode -> {
            line(indent, label("LetStatement", cfg))
            line(indent + 1, field("pattern", cfg) + ":")
            appendPattern(stmt.patternNode, indent + 2, cfg)
            stmt.typeNode?.let {
                line(indent + 1, field("type", cfg) + ":")
                appendType(it, indent + 2, cfg)
            }
            line(indent + 1, field("init", cfg) + ":")
            appendExpr(stmt.expressionNode, indent + 2, cfg)
        }
        is StatementNode.ExpressionStatementNode -> {
            line(indent, label("ExpressionStatement", cfg))
            appendExpr(stmt.expression, indent + 1, cfg)
        }
    }
}

// Expressions
private fun StringBuilder.appendExpr(expr: ExpressionNode, indent: Int, cfg: RenderConfig) {
    when (expr) {
        is ExpressionNode.WithBlockExpressionNode -> appendExprWithBlock(expr, indent, cfg)
        is ExpressionNode.WithoutBlockExpressionNode -> appendExprWithoutBlock(expr, indent, cfg)
    }
}

private fun StringBuilder.appendExprWithBlock(expr: ExpressionNode.WithBlockExpressionNode, indent: Int, cfg: RenderConfig) {
    when (expr) {
        is ExpressionNode.WithBlockExpressionNode.BlockExpressionNode -> {
            line(indent, label("Block", cfg))
            val hasStmts = expr.statements.isNotEmpty()
            val hasTail = expr.trailingExpression != null
            if (!hasStmts && !hasTail) {
                line(indent + 1, info("(empty)", cfg))
            } else {
                if (hasStmts) {
                    expr.statements.forEach { appendStmt(it, indent + 1, cfg) }
                }
                if (hasTail) {
                    line(indent + 1, field("trailing", cfg) + ":")
                    appendExpr(expr.trailingExpression!!, indent + 2, cfg)
                }
            }
        }
        is ExpressionNode.WithBlockExpressionNode.ConstBlockExpressionNode -> {
            line(indent, label("ConstBlock", cfg))
            appendExprWithBlock(expr.expression, indent + 1, cfg)
        }
        is ExpressionNode.WithBlockExpressionNode.LoopBlockExpressionNode -> {
            line(indent, label("LoopBlock", cfg))
            appendExprWithBlock(expr.expression, indent + 1, cfg)
        }
        is ExpressionNode.WithBlockExpressionNode.WhileBlockExpressionNode -> {
            line(indent, label("WhileBlock", cfg))
            line(indent + 1, field("condition", cfg) + ":")
            appendCondition(expr.condition, indent + 2, cfg)
            line(indent + 1, field("body", cfg) + ":")
            appendExprWithBlock(expr.expression, indent + 2, cfg)
        }
        is ExpressionNode.WithBlockExpressionNode.IfBlockExpressionNode -> {
            line(indent, label("IfBlock", cfg))
            expr.ifs.forEachIndexed { idx, br ->
                line(indent + 1, field("if[$idx]", cfg) + ":")
                appendIfBranch(br, indent + 2, cfg)
            }
            expr.elseBranch?.let { e ->
                line(indent + 1, field("else", cfg) + ":")
                appendExprWithBlock(e, indent + 2, cfg)
            }
        }
    }
}

private fun StringBuilder.appendExprWithoutBlock(expr: ExpressionNode.WithoutBlockExpressionNode, indent: Int, cfg: RenderConfig) {
    when (expr) {
        // Literals
        is ExpressionNode.WithoutBlockExpressionNode.LiteralExpressionNode.I32LiteralNode ->
            line(indent, label("I32", cfg) + " " + literal(expr.value.toString(), cfg))
        is ExpressionNode.WithoutBlockExpressionNode.LiteralExpressionNode.U32LiteralNode ->
            line(indent, label("U32", cfg) + " " + literal(expr.value.toString(), cfg))
        is ExpressionNode.WithoutBlockExpressionNode.LiteralExpressionNode.StringLiteralNode ->
            line(indent, label("String", cfg) + " " + literal("\"${expr.value}\"", cfg))
        is ExpressionNode.WithoutBlockExpressionNode.LiteralExpressionNode.CharLiteralNode ->
            line(indent, label("Char", cfg) + " " + literal("'${expr.value}'", cfg))
        is ExpressionNode.WithoutBlockExpressionNode.LiteralExpressionNode.BoolLiteralNode ->
            line(indent, label("Bool", cfg) + " " + literal("${expr.value}", cfg))

        // Simple
        is ExpressionNode.WithoutBlockExpressionNode.UnderscoreExpressionNode ->
            line(indent, literal("_", cfg))
        is ExpressionNode.WithoutBlockExpressionNode.PathExpressionNode ->
            line(indent, label("Path", cfg) + " " + value(expr.path.joinToString("::"), cfg))

        // Containers
        is ExpressionNode.WithoutBlockExpressionNode.TupleExpressionNode -> {
            line(indent, label("Tuple", cfg))
            expr.elements.forEachIndexed { i, e ->
                line(indent + 1, field("[$i]", cfg) + ":")
                appendExpr(e, indent + 2, cfg)
            }
        }
        is ExpressionNode.WithoutBlockExpressionNode.ArrayExpressionNode -> {
            line(indent, label("Array", cfg))
            expr.elements.forEachIndexed { i, e ->
                line(indent + 1, field("[$i]", cfg) + ":")
                appendExpr(e, indent + 2, cfg)
            }
        }

        // Modifiers / Accessors
        is ExpressionNode.WithoutBlockExpressionNode.CallExpressionNode -> {
            line(indent, label("Call", cfg))
            line(indent + 1, field("callee", cfg) + ":")
            appendExpr(expr.callee, indent + 2, cfg)
            if (expr.arguments.isNotEmpty()) {
                line(indent + 1, field("args", cfg) + ":")
                expr.arguments.forEachIndexed { i, a ->
                    line(indent + 2, field("[$i]", cfg) + ":")
                    appendExpr(a, indent + 3, cfg)
                }
            }
        }
        is ExpressionNode.WithoutBlockExpressionNode.IndexExpressionNode -> {
            line(indent, label("Index", cfg))
            line(indent + 1, field("base", cfg) + ":")
            appendExpr(expr.base, indent + 2, cfg)
            line(indent + 1, field("index", cfg) + ":")
            appendExpr(expr.index, indent + 2, cfg)
        }
        is ExpressionNode.WithoutBlockExpressionNode.FieldExpressionNode -> {
            line(indent, label("Field", cfg))
            line(indent + 1, field("base", cfg) + ":")
            appendExpr(expr.base, indent + 2, cfg)
            line(indent + 1, field("name", cfg) + ": " + value(expr.field, cfg))
        }
        is ExpressionNode.WithoutBlockExpressionNode.TupleIndexingNode -> {
            line(indent, label("TupleIndex", cfg))
            line(indent + 1, field("base", cfg) + ":")
            appendExpr(expr.base, indent + 2, cfg)
            line(indent + 1, field("index", cfg) + ": " + number(expr.index.toString(), cfg))
        }

        // Operators
        is ExpressionNode.WithoutBlockExpressionNode.InfixOperatorNode -> {
            line(indent, label("Infix", cfg) + " op=" + op(expr.op.toString(), cfg))
            line(indent + 1, field("left", cfg) + ":")
            appendExpr(expr.left, indent + 2, cfg)
            line(indent + 1, field("right", cfg) + ":")
            appendExpr(expr.right, indent + 2, cfg)
        }
        is ExpressionNode.WithoutBlockExpressionNode.PrefixOperatorNode -> {
            line(indent, label("Prefix", cfg) + " op=" + op(expr.op.toString(), cfg))
            line(indent + 1, field("expr", cfg) + ":")
            appendExpr(expr.expr, indent + 2, cfg)
        }

        // Control flow
        is ExpressionNode.WithoutBlockExpressionNode.ControlFlowExpressionNode.ReturnExpressionNode -> {
            line(indent, keyword("return", cfg))
            expr.expr?.let {
                line(indent + 1, field("value", cfg) + ":")
                appendExpr(it, indent + 2, cfg)
            }
        }
        is ExpressionNode.WithoutBlockExpressionNode.ControlFlowExpressionNode.BreakExpressionNode -> {
            line(indent, keyword("break", cfg))
            expr.expr?.let {
                line(indent + 1, field("value", cfg) + ":")
                appendExpr(it, indent + 2, cfg)
            }
        }
        is ExpressionNode.WithoutBlockExpressionNode.ControlFlowExpressionNode.ContinueExpressionNode ->
            line(indent, keyword("continue", cfg))
    }
}

// Support nodes
private fun StringBuilder.appendCondition(cond: ConditionsNode, indent: Int, cfg: RenderConfig) {
    line(indent, label("Condition", cfg))
    appendExpr(cond.expression, indent + 1, cfg)
}

private fun StringBuilder.appendIfBranch(br: IfBranchNode, indent: Int, cfg: RenderConfig) {
    line(indent, label("IfBranch", cfg))
    line(indent + 1, field("cond", cfg) + ":")
    appendCondition(br.condition, indent + 2, cfg)
    line(indent + 1, field("then", cfg) + ":")
    appendExprWithBlock(br.then, indent + 2, cfg)
}

// Pattern rendering
private fun StringBuilder.appendPattern(pat: PatternNode, indent: Int, cfg: RenderConfig) {
    val alts = pat.patternNodes
    if (alts.size == 1) {
        appendSupportingPattern(alts[0], indent, cfg)
    } else {
        line(indent, label("Pattern(|)", cfg))
        alts.forEachIndexed { i, p ->
            line(indent + 1, field("[$i]", cfg) + ":")
            appendSupportingPattern(p, indent + 2, cfg)
        }
    }
}

private fun StringBuilder.appendSupportingPattern(p: SupportingPatternNode, indent: Int, cfg: RenderConfig) {
    when (p) {
        is SupportingPatternNode.LiteralPatternNode -> {
            val neg = if (p.isNegated) " " + op("-", cfg) else ""
            line(indent, label("PatLiteral", cfg) + neg)
            // reuse literal renderer
            appendExpr(p.literalNode, indent + 1, cfg)
        }
        is SupportingPatternNode.IdentifierPatternNode -> {
            val mods = buildList {
                if (p.isRef) add(keyword("ref", cfg))
                if (p.isMut) add(keyword("mut", cfg))
            }.joinToString(" ")
            val head = listOf(label("PatIdent", cfg), mods, value(p.identifier, cfg))
                .filter { it.isNotEmpty() }
                .joinToString(" ")
            line(indent, head)
            p.extendedByPatternNode?.let { sub ->
                line(indent + 1, field("sub", cfg) + ":")
                appendPattern(sub, indent + 2, cfg)
            }
        }
        is SupportingPatternNode.WildcardPatternNode -> {
            line(indent, label("Wildcard (_)", cfg))
        }
    }
}

// Type rendering
private fun StringBuilder.appendType(type: TypeNode, indent: Int, cfg: RenderConfig) {
    when (type) {
        is TypeNode.TypePath -> {
            val prefix = if (type.isGlobal) "::" else ""
            val pathStr = type.path.joinToString("::") { seg ->
                when (seg) {
                    is TypePathSegment -> buildString {
                        append(seg.pathIndentSegment.raw)
                        seg.generics?.let { g ->
                            append("<")
                            append(g.args.joinToString(", ") { arg -> typeToInline(arg) })
                            append(">")
                        }
                    }
                    else -> seg.toString()
                }
            }
            line(indent, value(prefix + pathStr, cfg))
        }
        is TypeNode.NeverType -> {
            line(indent, label("Never", cfg))
            appendType(type.type, indent + 1, cfg)
        }
        is TypeNode.TupleType -> {
            line(indent, label("TupleType", cfg))
            if (type.types.isEmpty()) {
                line(indent + 1, info("(unit)", cfg))
            } else {
                type.types.forEachIndexed { i, t ->
                    line(indent + 1, field("[$i]", cfg) + ":")
                    appendType(t, indent + 2, cfg)
                }
            }
        }
        is TypeNode.ArrayType -> {
            line(indent, label("ArrayType", cfg))
            line(indent + 1, field("elem", cfg) + ":")
            appendType(type.type, indent + 2, cfg)
            line(indent + 1, field("len", cfg) + ":")
            appendExpr(type.length, indent + 2, cfg)
        }
        is TypeNode.SliceType -> {
            line(indent, label("SliceType", cfg))
            appendType(type.type, indent + 1, cfg)
        }
        is TypeNode.ReferenceType -> {
            val mutPart = if (type.isMut) " mut" else ""
            line(indent, label("RefType$mutPart", cfg))
            appendType(type.type, indent + 1, cfg)
        }
        TypeNode.InferredType -> line(indent, label("InferredType", cfg))
    }
}

// Inline helper for generic args
private fun typeToInline(t: TypeNode): String = when (t) {
    is TypeNode.TypePath -> (if (t.isGlobal) "::" else "") + t.path.joinToString("::") { seg ->
        if (seg is TypePathSegment) buildString {
            append(seg.pathIndentSegment.raw)
            seg.generics?.let { g ->
                append("<")
                append(g.args.joinToString(", ") { typeToInline(it) })
                append(">")
            }
        } else seg.toString()
    }
    is TypeNode.InferredType -> "_"
    is TypeNode.TupleType -> t.types.joinToString(prefix = "(", postfix = ")") { typeToInline(it) }
    is TypeNode.NeverType -> "!${typeToInline(t.type)}"
    is TypeNode.ArrayType -> "[${typeToInline(t.type)}; ...]" // length skipped for inline simplicity
    is TypeNode.SliceType -> "[${typeToInline(t.type)}]"
    is TypeNode.ReferenceType -> "&" + (if (t.isMut) "mut " else "") + typeToInline(t.type)
}

// Styling helpers
private fun label(text: String, cfg: RenderConfig) = text.cyanIf(cfg.color)
private fun field(text: String, cfg: RenderConfig) = text.grayIf(cfg.color)
private fun value(text: String, cfg: RenderConfig) = text.greenIf(cfg.color)
private fun number(text: String, cfg: RenderConfig) = text.blueIf(cfg.color)
private fun literal(text: String, cfg: RenderConfig) = text.yellowIf(cfg.color)
private fun keyword(text: String, cfg: RenderConfig) = text.magentaIf(cfg.color)
private fun op(text: String, cfg: RenderConfig) = text.redIf(cfg.color)
private fun info(text: String, cfg: RenderConfig) = text.grayIf(cfg.color)