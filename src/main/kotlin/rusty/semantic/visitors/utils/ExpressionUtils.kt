package rusty.semantic.visitors.utils

import rusty.core.CompileError
import rusty.lexer.Token
import rusty.semantic.support.SemanticType
import rusty.semantic.support.SemanticValue
import kotlin.reflect.KClass

class ExpressionAnalyzer {
    companion object {
        // Tables are generated by GPT-5 programmatically
        private val BINARY_OPS: Map<Token, (SemanticValue, SemanticValue) -> SemanticValue> = mapOf(
            // Arithmetic
            Token.O_PLUS to { l, r -> intArithmetic(l, r, Int::plus, UInt::plus) },
            Token.O_MINUS to { l, r -> intArithmetic(l, r, Int::minus, UInt::minus) },
            Token.O_STAR to { l, r -> intArithmetic(l, r, Int::times, UInt::times) },
            Token.O_DIV to { l, r -> intArithmetic(l, r, Int::div, UInt::div) },
            Token.O_PERCENT to { l, r -> intArithmetic(l, r, Int::rem, UInt::rem) },

            // Comparisons
            Token.O_DOUBLE_EQ to { l, r -> intOrBoolEq(l, r, true) },
            Token.O_NEQ to { l, r -> intOrBoolEq(l, r, false) },
            Token.O_LANG to { l, r -> intCompare(l, r, { a, b -> a < b }, { a, b -> a < b }) },
            Token.O_LEQ to { l, r -> intCompare(l, r, { a, b -> a <= b }, { a, b -> a <= b }) },
            Token.O_RANG to { l, r -> intCompare(l, r, { a, b -> a > b }, { a, b -> a > b }) },
            Token.O_GEQ to { l, r -> intCompare(l, r, { a, b -> a >= b }, { a, b -> a >= b }) },

            // Logical (bool)
            Token.O_DOUBLE_AND to { l, r -> boolLogic(l, r, op = { a, b -> a && b }) },
            Token.O_DOUBLE_OR to { l, r -> boolLogic(l, r, op = { a, b -> a || b }) },

            // Bitwise
            Token.O_AND to { l, r -> intBitwise(l, r, Int::and, UInt::and) },
            Token.O_OR to { l, r -> intBitwise(l, r, Int::or, UInt::or) },
            Token.O_BIT_XOR to { l, r -> intBitwise(l, r, Int::xor, UInt::xor) },

            // Shifts
            Token.O_SLFT to { l, r -> intShiftLeft(l, r) },
            Token.O_SRIT to { l, r -> intShiftRight(l, r) },
        )

        private val UNARY_OPS: Map<Token, (SemanticValue) -> SemanticValue> = mapOf(
            // Unary plus: no-op for integers
            Token.O_PLUS to { v -> unaryPlus(v) },
            // Unary minus: supported on signed and abstract integers
            Token.O_MINUS to { v -> unaryMinus(v) },
            // Logical/bitwise not: bool => logical not; int => bitwise not
            Token.O_NOT to { v -> unaryNot(v) },
        )

        fun tryImplicitCast(from: SemanticValue, to: SemanticType): SemanticValue {
            if (from::class == to)
                return from
            if (to == SemanticType.WildcardType)
                return from
            return when(from) {
                is SemanticValue.AnyIntValue ->
                     when (to) {
                         is SemanticType.I32Type -> SemanticValue.I32Value(from.value)
                         is SemanticType.U32Type -> SemanticValue.U32Value(from.value.toUInt())
                         is SemanticType.ISizeType -> SemanticValue.ISizeValue(from.value)
                         is SemanticType.USizeType -> SemanticValue.USizeValue(from.value.toUInt())
                         is SemanticType.AnySignedIntType -> SemanticValue.AnySignedIntValue(from.value)
                         else -> throw CompileError("No implicit cast from ${from::class.simpleName} to $to")
                     }
                is SemanticValue.AnySignedIntValue ->
                    when (to) {
                        is SemanticType.I32Type -> SemanticValue.I32Value(from.value)
                        is SemanticType.ISizeType -> SemanticValue.ISizeValue(from.value)
                        else -> throw CompileError("No implicit cast from ${from::class.simpleName} to $to")
                    }
                is SemanticValue.EnumValue ->
                    if (to is SemanticType.EnumType && to == from.type)
                        from
                    else
                        throw CompileError("No implicit cast from ${from::class.simpleName} to $to")
                is SemanticValue.ArrayValue ->
                    when (to) {
                        is SemanticType.ArrayType -> {
                            if (from.elements.isNotEmpty()) {
                                if (to.length.get().value == from.repeat.value * from.elements.size.toUInt())
                                    return SemanticValue.ArrayValue(from.type, from.elementType, from.elements, from.repeat)
                            } else {
                                val len = to.length.getOrNull()
                                if (len != null && len.value == 0U)
                                    return SemanticValue.ArrayValue(from.type, to.elementType.get(), emptyList(), from.repeat)
                            }
                            throw CompileError("No implicit cast from ${from::class.simpleName} to $to")
                        }
                        else -> throw CompileError("No implicit cast from ${from::class.simpleName} to $to")
                    }
                else -> throw CompileError("No implicit cast from ${from::class.simpleName} to $to")
            }
        }

        fun tryBinaryOperate(left: SemanticValue, right: SemanticValue, op: Token): SemanticValue {
            val handler = BINARY_OPS[op]
                ?: throw CompileError("Unsupported binary operator: $op on ${left::class.simpleName} and ${right::class.simpleName}")
            return handler(left, right)
        }

        fun tryUnaryOperate(value: SemanticValue, op: Token): SemanticValue {
            val handler = UNARY_OPS[op]
                ?: throw CompileError("Unsupported unary operator: $op on ${value::class.simpleName}")
            return handler(value)
        }

        private fun isSignedConcrete(v: SemanticValue) = v is SemanticValue.I32Value || v is SemanticValue.ISizeValue
        private fun isUnsignedConcrete(v: SemanticValue) = v is SemanticValue.U32Value || v is SemanticValue.USizeValue
        private fun isAnySigned(v: SemanticValue) = v is SemanticValue.AnySignedIntValue
        private fun isAnyInt(v: SemanticValue) = v is SemanticValue.AnyIntValue

        private fun requireSameOrAbstractForSigned(left: SemanticValue, right: SemanticValue, opName: String) {
            val ok = when (left) {
                is SemanticValue.I32Value -> right is SemanticValue.I32Value || isAnyInt(right) || isAnySigned(right)
                is SemanticValue.ISizeValue -> right is SemanticValue.ISizeValue || isAnyInt(right) || isAnySigned(right)
                is SemanticValue.AnySignedIntValue -> right is SemanticValue.I32Value || right is SemanticValue.ISizeValue || isAnySigned(right)
                else -> false
            }
            if (!ok) throw CompileError("Cannot $opName ${left::class.simpleName} and ${right::class.simpleName}")
        }

        private fun requireSameOrAbstractForUnsigned(left: SemanticValue, right: SemanticValue, opName: String) {
            // Allow: U32 with (U32|AnyInt), USize with (USize|AnyInt)
            val ok = when (left) {
                is SemanticValue.U32Value -> right is SemanticValue.U32Value || isAnyInt(right)
                is SemanticValue.USizeValue -> right is SemanticValue.USizeValue || isAnyInt(right)
                else -> false
            }
            if (!ok) throw CompileError("Cannot $opName ${left::class.simpleName} and ${right::class.simpleName}")
        }

        private fun toSignedInt(v: SemanticValue): Int = when (v) {
            is SemanticValue.I32Value -> v.value
            is SemanticValue.ISizeValue -> v.value
            is SemanticValue.AnyIntValue -> v.value
            is SemanticValue.AnySignedIntValue -> v.value
            else -> throw CompileError("Expected signed integer, got ${v::class.simpleName}")
        }

        private fun toUnsignedInt(v: SemanticValue): UInt = when (v) {
            is SemanticValue.U32Value -> v.value
            is SemanticValue.USizeValue -> v.value
            is SemanticValue.AnyIntValue -> v.value.toUInt()
            else -> throw CompileError("Expected unsigned integer, got ${v::class.simpleName}")
        }

        private fun intArithmetic(
            left: SemanticValue,
            right: SemanticValue,
            opSigned: (Int, Int) -> Int,
            opUnsigned: (UInt, UInt) -> UInt,
        ): SemanticValue {
            return when (left) {
                is SemanticValue.I32Value -> {
                    requireSameOrAbstractForSigned(left, right, "operate")
                    val a = left.value
                    val b = toSignedInt(right)
                    SemanticValue.I32Value(opSigned(a, b))
                }
                is SemanticValue.ISizeValue -> {
                    requireSameOrAbstractForSigned(left, right, "operate")
                    val a = left.value
                    val b = toSignedInt(right)
                    SemanticValue.ISizeValue(opSigned(a, b))
                }
                is SemanticValue.U32Value -> {
                    requireSameOrAbstractForUnsigned(left, right, "operate")
                    val a = left.value
                    val b = toUnsignedInt(right)
                    SemanticValue.U32Value(opUnsigned(a, b))
                }
                is SemanticValue.USizeValue -> {
                    requireSameOrAbstractForUnsigned(left, right, "operate")
                    val a = left.value
                    val b = toUnsignedInt(right)
                    SemanticValue.USizeValue(opUnsigned(a, b))
                }
                is SemanticValue.AnySignedIntValue -> {
                    requireSameOrAbstractForSigned(left, right, "operate")
                    val a = left.value
                    when (right) {
                        is SemanticValue.I32Value -> SemanticValue.I32Value(opSigned(a, right.value))
                        is SemanticValue.ISizeValue -> SemanticValue.ISizeValue(opSigned(a, right.value))
                        is SemanticValue.AnySignedIntValue -> SemanticValue.AnySignedIntValue(opSigned(a, right.value))
                        is SemanticValue.AnyIntValue -> SemanticValue.AnySignedIntValue(opSigned(a, right.value))
                        else -> throw CompileError("Cannot operate AnySignedInt and ${right::class.simpleName}")
                    }
                }
                is SemanticValue.AnyIntValue -> {
                    val a = left.value
                    when (right) {
                        is SemanticValue.I32Value -> SemanticValue.I32Value(opSigned(a, right.value))
                        is SemanticValue.ISizeValue -> SemanticValue.ISizeValue(opSigned(a, right.value))
                        is SemanticValue.U32Value -> SemanticValue.U32Value(opUnsigned(a.toUInt(), right.value))
                        is SemanticValue.USizeValue -> SemanticValue.USizeValue(opUnsigned(a.toUInt(), right.value))
                        is SemanticValue.AnySignedIntValue -> SemanticValue.AnySignedIntValue(opSigned(a, right.value))
                        is SemanticValue.AnyIntValue -> SemanticValue.AnyIntValue(opSigned(a, right.value))
                        else -> throw CompileError("Cannot operate AnyInt and ${right::class.simpleName}")
                    }
                }
                else -> throw CompileError("Cannot operate ${left::class.simpleName} and ${right::class.simpleName}")
            }
        }

        private fun intCompare(
            left: SemanticValue,
            right: SemanticValue,
            cmpSigned: (Int, Int) -> Boolean,
            cmpUnsigned: (UInt, UInt) -> Boolean,
        ): SemanticValue.BoolValue {
            return when (left) {
                is SemanticValue.I32Value -> {
                    requireSameOrAbstractForSigned(left, right, "compare")
                    SemanticValue.BoolValue(cmpSigned(left.value, toSignedInt(right)))
                }
                is SemanticValue.ISizeValue -> {
                    requireSameOrAbstractForSigned(left, right, "compare")
                    SemanticValue.BoolValue(cmpSigned(left.value, toSignedInt(right)))
                }
                is SemanticValue.U32Value -> {
                    requireSameOrAbstractForUnsigned(left, right, "compare")
                    SemanticValue.BoolValue(cmpUnsigned(left.value, toUnsignedInt(right)))
                }
                is SemanticValue.USizeValue -> {
                    requireSameOrAbstractForUnsigned(left, right, "compare")
                    SemanticValue.BoolValue(cmpUnsigned(left.value, toUnsignedInt(right)))
                }
                is SemanticValue.AnySignedIntValue -> {
                    requireSameOrAbstractForSigned(left, right, "compare")
                    val a = left.value
                    val b = when (right) {
                        is SemanticValue.I32Value -> right.value
                        is SemanticValue.ISizeValue -> right.value
                        is SemanticValue.AnySignedIntValue -> right.value
                        is SemanticValue.AnyIntValue -> right.value
                        else -> throw CompileError("Cannot compare AnySignedInt and ${right::class.simpleName}")
                    }
                    SemanticValue.BoolValue(cmpSigned(a, b))
                }
                is SemanticValue.AnyIntValue -> {
                    val a = left.value
                    val res = when (right) {
                        is SemanticValue.I32Value -> cmpSigned(a, right.value)
                        is SemanticValue.ISizeValue -> cmpSigned(a, right.value)
                        is SemanticValue.U32Value -> cmpUnsigned(a.toUInt(), right.value)
                        is SemanticValue.USizeValue -> cmpUnsigned(a.toUInt(), right.value)
                        is SemanticValue.AnySignedIntValue -> cmpSigned(a, right.value)
                        is SemanticValue.AnyIntValue -> cmpSigned(a, right.value)
                        else -> throw CompileError("Cannot compare AnyInt and ${right::class.simpleName}")
                    }
                    SemanticValue.BoolValue(res)
                }
                else -> throw CompileError("Cannot compare ${left::class.simpleName} and ${right::class.simpleName}")
            }
        }

        // Equality for ints and bools/chars/strings
        private fun intOrBoolEq(left: SemanticValue, right: SemanticValue, eq: Boolean): SemanticValue.BoolValue {
            if (left is SemanticValue.BoolValue && right is SemanticValue.BoolValue) {
                return SemanticValue.BoolValue(if (eq) left.value == right.value else left.value != right.value)
            }
            // Handle char
            if (left is SemanticValue.CharValue && right is SemanticValue.CharValue) {
                return SemanticValue.BoolValue(if (eq) left.value == right.value else left.value != right.value)
            }
            // Handle strings (both String and CString separately, no cross-compare)
            if (left is SemanticValue.StringValue && right is SemanticValue.StringValue) {
                return SemanticValue.BoolValue(if (eq) left.value == right.value else left.value != right.value)
            }
            if (left is SemanticValue.CStringValue && right is SemanticValue.CStringValue) {
                return SemanticValue.BoolValue(if (eq) left.value == right.value else left.value != right.value)
            }

            val res = when (left) {
                is SemanticValue.I32Value -> {
                    requireSameOrAbstractForSigned(left, right, "compare")
                    left.value == toSignedInt(right)
                }
                is SemanticValue.ISizeValue -> {
                    requireSameOrAbstractForSigned(left, right, "compare")
                    left.value == toSignedInt(right)
                }
                is SemanticValue.U32Value -> {
                    requireSameOrAbstractForUnsigned(left, right, "compare")
                    left.value == toUnsignedInt(right)
                }
                is SemanticValue.USizeValue -> {
                    requireSameOrAbstractForUnsigned(left, right, "compare")
                    left.value == toUnsignedInt(right)
                }
                is SemanticValue.AnySignedIntValue -> {
                    requireSameOrAbstractForSigned(left, right, "compare")
                    val b = when (right) {
                        is SemanticValue.I32Value -> right.value
                        is SemanticValue.ISizeValue -> right.value
                        is SemanticValue.AnySignedIntValue -> right.value
                        is SemanticValue.AnyIntValue -> right.value
                        else -> throw CompileError("Cannot compare AnySignedInt and ${right::class.simpleName}")
                    }
                    left.value == b
                }
                is SemanticValue.AnyIntValue -> {
                    when (right) {
                        is SemanticValue.I32Value -> left.value == right.value
                        is SemanticValue.ISizeValue -> left.value == right.value
                        is SemanticValue.U32Value -> left.value.toUInt() == right.value
                        is SemanticValue.USizeValue -> left.value.toUInt() == right.value
                        is SemanticValue.AnySignedIntValue -> left.value == right.value
                        is SemanticValue.AnyIntValue -> left.value == right.value
                        else -> throw CompileError("Cannot compare AnyInt and ${right::class.simpleName}")
                    }
                }
                else -> throw CompileError("Cannot compare ${left::class.simpleName} and ${right::class.simpleName}")
            }
            return SemanticValue.BoolValue(if (eq) res else !res)
        }

        private fun boolLogic(
            left: SemanticValue,
            right: SemanticValue,
            op: (Boolean, Boolean) -> Boolean,
        ): SemanticValue.BoolValue {
            if (left is SemanticValue.BoolValue && right is SemanticValue.BoolValue) {
                return SemanticValue.BoolValue(op(left.value, right.value))
            }
            throw CompileError("Logical operation requires booleans, got ${left::class.simpleName} and ${right::class.simpleName}")
        }

        private fun intBitwise(
            left: SemanticValue,
            right: SemanticValue,
            opSigned: (Int, Int) -> Int,
            opUnsigned: (UInt, UInt) -> UInt,
        ): SemanticValue {
            return intArithmetic(left, right, opSigned, opUnsigned) // same type resolution, different ops
        }

        private fun intShiftLeft(left: SemanticValue, right: SemanticValue): SemanticValue {
            val shift = toShiftAmount(right)
            return when (left) {
                is SemanticValue.I32Value -> SemanticValue.I32Value(left.value shl shift)
                is SemanticValue.ISizeValue -> SemanticValue.ISizeValue(left.value shl shift)
                is SemanticValue.U32Value -> SemanticValue.U32Value(left.value shl shift)
                is SemanticValue.USizeValue -> SemanticValue.USizeValue(left.value shl shift)
                is SemanticValue.AnySignedIntValue -> SemanticValue.AnySignedIntValue(left.value shl shift)
                is SemanticValue.AnyIntValue -> SemanticValue.AnyIntValue(left.value shl shift)
                else -> throw CompileError("Cannot shift ${left::class.simpleName}")
            }
        }

        private fun intShiftRight(left: SemanticValue, right: SemanticValue): SemanticValue {
            val shift = toShiftAmount(right)
            return when (left) {
                is SemanticValue.I32Value -> SemanticValue.I32Value(left.value shr shift)
                is SemanticValue.ISizeValue -> SemanticValue.ISizeValue(left.value shr shift)
                is SemanticValue.U32Value -> SemanticValue.U32Value(left.value shr shift)
                is SemanticValue.USizeValue -> SemanticValue.USizeValue(left.value shr shift)
                is SemanticValue.AnySignedIntValue -> SemanticValue.AnySignedIntValue(left.value shr shift)
                is SemanticValue.AnyIntValue -> SemanticValue.AnyIntValue(left.value shr shift)
                else -> throw CompileError("Cannot shift ${left::class.simpleName}")
            }
        }

        private fun toShiftAmount(v: SemanticValue): Int = when (v) {
            is SemanticValue.I32Value -> v.value
            is SemanticValue.ISizeValue -> v.value
            is SemanticValue.AnySignedIntValue -> v.value
            is SemanticValue.AnyIntValue -> v.value
            is SemanticValue.U32Value -> v.value.toInt()
            is SemanticValue.USizeValue -> v.value.toInt()
            else -> throw CompileError("Shift amount must be an integer, got ${v::class.simpleName}")
        }

        private fun unaryPlus(v: SemanticValue): SemanticValue = when (v) {
            is SemanticValue.I32Value,
            is SemanticValue.U32Value,
            is SemanticValue.ISizeValue,
            is SemanticValue.USizeValue,
            is SemanticValue.AnyIntValue,
            is SemanticValue.AnySignedIntValue -> v
            else -> throw CompileError("Unary plus not supported for ${v::class.simpleName}")
        }

        private fun unaryMinus(v: SemanticValue): SemanticValue = when (v) {
            is SemanticValue.I32Value -> SemanticValue.I32Value(-v.value)
            is SemanticValue.ISizeValue -> SemanticValue.ISizeValue(-v.value)
            is SemanticValue.AnyIntValue -> SemanticValue.AnySignedIntValue(-v.value)
            is SemanticValue.AnySignedIntValue -> SemanticValue.AnySignedIntValue(-v.value)
            else -> throw CompileError("Unary minus not supported for ${v::class.simpleName}")
        }

        private fun unaryNot(v: SemanticValue): SemanticValue = when (v) {
            is SemanticValue.BoolValue -> SemanticValue.BoolValue(!v.value)
            is SemanticValue.I32Value -> SemanticValue.I32Value(v.value.inv())
            is SemanticValue.ISizeValue -> SemanticValue.ISizeValue(v.value.inv())
            is SemanticValue.U32Value -> SemanticValue.U32Value(v.value.inv())
            is SemanticValue.USizeValue -> SemanticValue.USizeValue(v.value.inv())
            is SemanticValue.AnyIntValue -> SemanticValue.AnyIntValue(v.value.inv())
            is SemanticValue.AnySignedIntValue -> SemanticValue.AnySignedIntValue(v.value.inv())
            else -> throw CompileError("Unary ! not supported for ${v::class.simpleName}")
        }
    }
}