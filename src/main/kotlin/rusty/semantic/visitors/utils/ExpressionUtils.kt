package rusty.semantic.visitors.utils

import rusty.core.CompileError
import rusty.lexer.Token
import rusty.parser.nodes.ExpressionNode
import rusty.semantic.support.SemanticType
import rusty.semantic.support.SemanticValue
import kotlin.reflect.KClass

class ExpressionAnalyzer {
    companion object {
        // This file is generated by GPT-5 programmatically
        private val BINARY_OPS: Map<Token, (SemanticValue, SemanticValue) -> SemanticValue> = mapOf(
            // Arithmetic
            Token.O_PLUS to { l, r -> intArithmetic(l, r, Int::plus, UInt::plus) },
            Token.O_MINUS to { l, r -> intArithmetic(l, r, Int::minus, UInt::minus) },
            Token.O_STAR to { l, r -> intArithmetic(l, r, Int::times, UInt::times) },
            Token.O_DIV to { l, r -> intArithmetic(l, r, Int::div, UInt::div) },
            Token.O_PERCENT to { l, r -> intArithmetic(l, r, Int::rem, UInt::rem) },

            // Comparisons
            Token.O_DOUBLE_EQ to { l, r -> intOrBoolEq(l, r, true) },
            Token.O_NEQ to { l, r -> intOrBoolEq(l, r, false) },
            Token.O_LANG to { l, r -> intCompare(l, r, { a, b -> a < b }, { a, b -> a < b }) },
            Token.O_LEQ to { l, r -> intCompare(l, r, { a, b -> a <= b }, { a, b -> a <= b }) },
            Token.O_RANG to { l, r -> intCompare(l, r, { a, b -> a > b }, { a, b -> a > b }) },
            Token.O_GEQ to { l, r -> intCompare(l, r, { a, b -> a >= b }, { a, b -> a >= b }) },

            // Logical (bool)
            Token.O_DOUBLE_AND to { l, r -> boolLogic(l, r, op = { a, b -> a && b }) },
            Token.O_DOUBLE_OR to { l, r -> boolLogic(l, r, op = { a, b -> a || b }) },

            // Bitwise
            Token.O_AND to { l, r -> intBitwise(l, r, Int::and, UInt::and) },
            Token.O_OR to { l, r -> intBitwise(l, r, Int::or, UInt::or) },
            Token.O_BIT_XOR to { l, r -> intBitwise(l, r, Int::xor, UInt::xor) },

            // Shifts
            Token.O_SLFT to { l, r -> intShiftLeft(l, r) },
            Token.O_SRIT to { l, r -> intShiftRight(l, r) },
        )

        private val UNARY_OPS: Map<Token, (SemanticValue) -> SemanticValue> = mapOf(
            // Unary plus: no-op for integers
            Token.O_PLUS to { v -> unaryPlus(v) },
            // Unary minus: supported on signed and abstract integers
            Token.O_MINUS to { v -> unaryMinus(v) },
            // Logical/bitwise not: bool => logical not; int => bitwise not
            Token.O_NOT to { v -> unaryNot(v) },
        )

        fun tryImplicitCast(from: SemanticValue, to: SemanticType): SemanticValue {
            if (from.type == to)
                return from
            if (to == SemanticType.WildcardType)
                return from
            return when (from) {
                is SemanticValue.AnyIntValue ->
                    when (to) {
                        is SemanticType.I32Type -> SemanticValue.I32Value(from.value)
                        is SemanticType.U32Type -> SemanticValue.U32Value(from.value.toUInt())
                        is SemanticType.ISizeType -> SemanticValue.ISizeValue(from.value)
                        is SemanticType.USizeType -> SemanticValue.USizeValue(from.value.toUInt())
                        is SemanticType.AnySignedIntType -> SemanticValue.AnySignedIntValue(from.value)
                        else -> throw CompileError("No implicit cast from ${from::class.simpleName} to $to")
                    }

                is SemanticValue.AnySignedIntValue ->
                    when (to) {
                        is SemanticType.I32Type -> SemanticValue.I32Value(from.value)
                        is SemanticType.ISizeType -> SemanticValue.ISizeValue(from.value)
                        else -> throw CompileError("No implicit cast from ${from::class.simpleName} to $to")
                    }

                is SemanticValue.EnumValue ->
                    if (to is SemanticType.EnumType && to == from.type)
                        from
                    else
                        throw CompileError("No implicit cast from ${from::class.simpleName} to $to")

                is SemanticValue.ArrayValue ->
                    when (to) {
                        is SemanticType.ArrayType -> {
                            if (from.elements.isNotEmpty()) {
                                if (to.length.get().value == from.repeat.value * from.elements.size.toUInt())
                                    return SemanticValue.ArrayValue(
                                        from.type,
                                        from.elementType,
                                        from.elements,
                                        from.repeat
                                    )
                            } else {
                                val len = to.length.getOrNull()
                                if (len != null && len.value == 0U)
                                    return SemanticValue.ArrayValue(
                                        from.type,
                                        to.elementType.get(),
                                        emptyList(),
                                        from.repeat
                                    )
                            }
                            throw CompileError("No implicit cast from ${from::class.simpleName} to $to")
                        }

                        else -> throw CompileError("No implicit cast from ${from::class.simpleName} to $to")
                    }

                else -> throw CompileError("No implicit cast from ${from::class.simpleName} to $to")
            }
        }

        fun tryImplicitCast(from: SemanticType, to: SemanticType): SemanticType {
            if (from == to) return from
            if (to == SemanticType.WildcardType) return from

            return when (from) {
                is SemanticType.AnyIntType -> when (to) {
                    is SemanticType.I32Type,
                    is SemanticType.U32Type,
                    is SemanticType.ISizeType,
                    is SemanticType.USizeType,
                    is SemanticType.AnySignedIntType -> to

                    else -> throw CompileError("No implicit cast from ${from::class.simpleName} to $to")
                }

                is SemanticType.AnySignedIntType -> when (to) {
                    is SemanticType.I32Type,
                    is SemanticType.ISizeType -> to

                    else -> throw CompileError("No implicit cast from ${from::class.simpleName} to $to")
                }

                is SemanticType.EnumType -> if (to is SemanticType.EnumType && to.identifier == from.identifier) to
                else throw CompileError("No implicit cast from ${from::class.simpleName} to $to")

                is SemanticType.ArrayType -> when (to) {
                    is SemanticType.ArrayType -> {
                        // If both lengths are known, they must match
                        val fl = from.length.getOrNull()?.value
                        val tl = to.length.getOrNull()?.value
                        if (fl != null && tl != null && fl != tl)
                            throw CompileError("No implicit cast between arrays of different lengths: $fl vs $tl")
                        // Element types must be implicitly castable
                        val fe = from.elementType.getOrNull()
                            ?: throw CompileError("Unresolved array element type: $from")
                        val te = to.elementType.getOrNull()
                            ?: throw CompileError("Unresolved array element type: $to")
                        tryImplicitCast(fe, te)
                        to
                    }

                    else -> throw CompileError("No implicit cast from ${from::class.simpleName} to $to")
                }

                else -> throw CompileError("No implicit cast from ${from::class.simpleName} to $to")
            }
        }

        fun tryBinaryOperate(left: SemanticValue, right: SemanticValue, op: Token): SemanticValue {
            val handler = BINARY_OPS[op]
                ?: throw CompileError("Unsupported binary operator: $op on ${left::class.simpleName} and ${right::class.simpleName}")
            return handler(left, right)
        }

        fun tryBinaryOperate(left: SemanticType, right: SemanticType, op: Token): SemanticType {
            return when (op) {
                // Arithmetic
                Token.O_PLUS, Token.O_MINUS, Token.O_STAR, Token.O_DIV, Token.O_PERCENT -> intArithmeticType(
                    left,
                    right,
                    opName = op.toString()
                )

                // Comparisons (including <, <=, >, >=)
                Token.O_LANG, Token.O_LEQ, Token.O_RANG, Token.O_GEQ -> {
                    intCompareType(left, right, opName = "compare"); SemanticType.BoolType
                }

                // Equality/inequality
                Token.O_DOUBLE_EQ, Token.O_NEQ -> intOrBoolEqType(left, right)

                // Logical (bool)
                Token.O_DOUBLE_AND, Token.O_DOUBLE_OR -> {
                    if (left is SemanticType.BoolType && right is SemanticType.BoolType) SemanticType.BoolType
                    else throw CompileError("Logical operation requires booleans, got $left and $right")
                }

                // Bitwise
                Token.O_AND, Token.O_OR, Token.O_BIT_XOR -> intArithmeticType(left, right, opName = "operate")

                // Shifts
                Token.O_SLFT, Token.O_SRIT -> {
                    if (!isIntType(left)) throw CompileError("Cannot shift $left")
                    if (!isIntType(right)) throw CompileError("Shift amount must be an integer, got $right")
                    left
                }

                else -> throw CompileError("Unsupported binary operator: $op on $left and $right")
            }
        }

        fun tryUnaryOperate(value: SemanticValue, op: Token): SemanticValue {
            val handler = UNARY_OPS[op]
                ?: throw CompileError("Unsupported unary operator: $op on ${value::class.simpleName}")
            return handler(value)
        }

        fun tryUnaryOperate(value: SemanticType, op: Token): SemanticType {
            return when (op) {
                Token.O_PLUS -> when (value) {
                    is SemanticType.I32Type,
                    is SemanticType.U32Type,
                    is SemanticType.ISizeType,
                    is SemanticType.USizeType,
                    is SemanticType.AnyIntType,
                    is SemanticType.AnySignedIntType -> value

                    else -> throw CompileError("Unary plus not supported for $value")
                }

                Token.O_MINUS -> when (value) {
                    is SemanticType.I32Type -> value
                    is SemanticType.ISizeType -> value
                    is SemanticType.AnyIntType -> SemanticType.AnySignedIntType
                    is SemanticType.AnySignedIntType -> value
                    else -> throw CompileError("Unary minus not supported for $value")
                }

                Token.O_NOT -> when (value) {
                    is SemanticType.BoolType -> SemanticType.BoolType
                    is SemanticType.I32Type,
                    is SemanticType.U32Type,
                    is SemanticType.ISizeType,
                    is SemanticType.USizeType,
                    is SemanticType.AnyIntType,
                    is SemanticType.AnySignedIntType -> value

                    else -> throw CompileError("Unary ! not supported for $value")
                }

                else -> throw CompileError("Unsupported unary operator: $op on $value")
            }
        }

        // Explicit cast semantics for the `as` keyword.
        // Permits conversions across integer families (signed/unsigned/any/int sizes), from char to integers,
        // arrays with element-wise casts (length must match), and structs/enums (same identifier only).
        // Other casts are rejected.
        fun tryExplicitCast(from: SemanticValue, to: SemanticType): SemanticValue {
            if (from.type == to) return from

            fun intTo(target: SemanticType, v: Int): SemanticValue = when (target) {
                is SemanticType.I32Type -> SemanticValue.I32Value(v)
                is SemanticType.ISizeType -> SemanticValue.ISizeValue(v)
                is SemanticType.U32Type -> SemanticValue.U32Value(v.toUInt())
                is SemanticType.USizeType -> SemanticValue.USizeValue(v.toUInt())
                is SemanticType.AnyIntType -> SemanticValue.AnyIntValue(v)
                is SemanticType.AnySignedIntType -> SemanticValue.AnySignedIntValue(v)
                else -> throw CompileError("Invalid explicit cast to $target")
            }

            fun uintTo(target: SemanticType, v: UInt): SemanticValue = when (target) {
                is SemanticType.I32Type -> SemanticValue.I32Value(v.toInt())
                is SemanticType.ISizeType -> SemanticValue.ISizeValue(v.toInt())
                is SemanticType.U32Type -> SemanticValue.U32Value(v)
                is SemanticType.USizeType -> SemanticValue.USizeValue(v)
                is SemanticType.AnyIntType -> SemanticValue.AnyIntValue(v.toInt())
                is SemanticType.AnySignedIntType -> SemanticValue.AnySignedIntValue(v.toInt())
                else -> throw CompileError("Invalid explicit cast to $target")
            }

            return when (from) {
                is SemanticValue.I32Value -> intTo(to, from.value)
                is SemanticValue.ISizeValue -> intTo(to, from.value)
                is SemanticValue.U32Value -> uintTo(to, from.value)
                is SemanticValue.USizeValue -> uintTo(to, from.value)
                is SemanticValue.AnyIntValue -> intTo(to, from.value)
                is SemanticValue.AnySignedIntValue -> intTo(to, from.value)

                is SemanticValue.CharValue -> when (to) {
                    is SemanticType.I32Type, is SemanticType.ISizeType,
                    is SemanticType.AnyIntType, is SemanticType.AnySignedIntType -> intTo(to, from.value.code)

                    else -> throw CompileError("Cannot cast char to $to explicitly")
                }

                is SemanticValue.BoolValue -> throw CompileError("Cannot cast bool to $to explicitly")

                is SemanticValue.StringValue, is SemanticValue.CStringValue -> throw CompileError("Cannot cast ${from::class.simpleName} to $to explicitly")

                // Arrays: allow element-wise casts if total length matches and destination element type is known.
                is SemanticValue.ArrayValue -> when (to) {
                    is SemanticType.ArrayType -> {
                        val toLen = to.length.getOrNull()?.value
                            ?: throw CompileError("Cannot cast to array with unresolved length: $to")
                        val fromLen = (from.elements.size.toUInt() * from.repeat.value)
                        if (toLen != fromLen)
                            throw CompileError("Array length mismatch in explicit cast: $fromLen vs $toLen")

                        val toElemType = to.elementType.getOrNull()
                            ?: throw CompileError("Cannot cast to array with unresolved element type: $to")

                        val castedElems = from.elements.map { tryExplicitCast(it, toElemType) }
                        SemanticValue.ArrayValue(
                            type = to,
                            elementType = toElemType,
                            elements = castedElems,
                            repeat = from.repeat,
                        )
                    }

                    else -> throw CompileError("Cannot cast ${from::class.simpleName} to $to explicitly")
                }

                // Structs: only allow casts to the same struct identifier; perform per-field casts.
                is SemanticValue.StructValue -> when (to) {
                    is SemanticType.StructType -> {
                        if (from.type.identifier != to.identifier)
                            throw CompileError("Cannot cast struct ${from.type.identifier} to ${to.identifier}")
                        // Ensure field sets match
                        val toFields = to.fields
                        val fromFields = from.fields
                        if (toFields.keys != fromFields.keys)
                            throw CompileError("Struct field mismatch when casting to ${to.identifier}")

                        val casted = toFields.mapValues { (name, slot) ->
                            val targetTy = slot.getOrNull()
                                ?: throw CompileError("Unresolved field type '$name' in target struct ${to.identifier}")
                            val v = fromFields[name]
                                ?: throw CompileError("Missing field '$name' in source struct ${from.type.identifier}")
                            tryExplicitCast(v, targetTy)
                        }
                        SemanticValue.StructValue(to, casted)
                    }

                    else -> throw CompileError("Cannot cast ${from::class.simpleName} to $to explicitly")
                }

                // Enums: only allow no-op cast to the exact same enum identifier (no payloads supported here).
                is SemanticValue.EnumValue -> when (to) {
                    is SemanticType.EnumType -> {
                        if (from.type.identifier != to.identifier)
                            throw CompileError("Cannot cast enum ${from.type.identifier} to ${to.identifier}")
                        from
                    }

                    else -> throw CompileError("Cannot cast ${from::class.simpleName} to $to explicitly")
                }

                is SemanticValue.UnitValue -> throw CompileError("Cannot cast ${from::class.simpleName} to $to explicitly")

                is SemanticValue.ReferenceValue -> throw CompileError("Explicit casts for references are not supported: ${from.type} as $to")
            }
        }

        fun tryExplicitCast(from: SemanticType, to: SemanticType): SemanticType {
            if (from == to) return from
            return when (from) {
                // Integer families: allow explicit casts across all integer kinds
                is SemanticType.I32Type, is SemanticType.ISizeType,
                is SemanticType.U32Type, is SemanticType.USizeType,
                is SemanticType.AnyIntType, is SemanticType.AnySignedIntType -> when (to) {
                    is SemanticType.I32Type,
                    is SemanticType.ISizeType,
                    is SemanticType.U32Type,
                    is SemanticType.USizeType,
                    is SemanticType.AnyIntType,
                    is SemanticType.AnySignedIntType -> to

                    else -> throw CompileError("Invalid explicit cast to $to")
                }

                // Char -> integer kinds
                is SemanticType.CharType -> when (to) {
                    is SemanticType.I32Type, is SemanticType.ISizeType,
                    is SemanticType.AnyIntType, is SemanticType.AnySignedIntType -> to

                    else -> throw CompileError("Cannot cast char to $to explicitly")
                }

                // Bool cannot be explicitly cast anywhere else
                is SemanticType.BoolType -> throw CompileError("Cannot cast bool to $to explicitly")

                // Strings cannot be explicitly cast elsewhere
                is SemanticType.StringType, is SemanticType.CStringType -> throw CompileError("Cannot cast $from to $to explicitly")

                // Arrays: element-wise explicit cast if lengths are compatible
                is SemanticType.ArrayType -> when (to) {
                    is SemanticType.ArrayType -> {
                        val fl = from.length.getOrNull()?.value
                        val tl = to.length.getOrNull()?.value
                        if (fl != null && tl != null && fl != tl)
                            throw CompileError("Array length mismatch in explicit cast: $fl vs $tl")
                        val fe = from.elementType.getOrNull()
                            ?: throw CompileError("Unresolved array element type: $from")
                        val te = to.elementType.getOrNull()
                            ?: throw CompileError("Unresolved array element type: $to")
                        tryExplicitCast(fe, te)
                        to
                    }

                    else -> throw CompileError("Cannot cast $from to $to explicitly")
                }

                // Structs: same identifier only; per-field cast check
                is SemanticType.StructType -> when (to) {
                    is SemanticType.StructType -> {
                        if (from.identifier != to.identifier)
                            throw CompileError("Cannot cast struct ${from.identifier} to ${to.identifier}")
                        if (from.fields.keys != to.fields.keys)
                            throw CompileError("Struct field mismatch when casting to ${to.identifier}")
                        to.fields.forEach { (name, slotTo) ->
                            val targetTy = slotTo.getOrNull()
                                ?: throw CompileError("Unresolved field type '$name' in target struct ${to.identifier}")
                            val srcTy = from.fields[name]?.getOrNull()
                                ?: throw CompileError("Unresolved field type '$name' in source struct ${from.identifier}")
                            tryExplicitCast(srcTy, targetTy)
                        }
                        to
                    }

                    else -> throw CompileError("Cannot cast $from to $to explicitly")
                }

                // Enums: only same identifier allowed
                is SemanticType.EnumType -> when (to) {
                    is SemanticType.EnumType -> {
                        if (from.identifier != to.identifier)
                            throw CompileError("Cannot cast enum ${from.identifier} to ${to.identifier}")
                        to
                    }

                    else -> throw CompileError("Cannot cast $from to $to explicitly")
                }

                // Unit and references not supported for explicit casts here
                is SemanticType.UnitType -> throw CompileError("Cannot cast unit to $to explicitly")
                is SemanticType.ReferenceType -> throw CompileError("Explicit casts for references are not supported: $from as $to")

                is SemanticType.WildcardType -> to
                is SemanticType.TraitType -> throw CompileError("Cannot explicitly cast trait objects: $from as $to")
                is SemanticType.NeverType -> throw CompileError("Cannot explicitly cast never type: $from as $to")
                is SemanticType.FunctionHeader -> throw CompileError("Cannot explicitly cast function types: $from as $to")
            }
        }

        fun resolveBuiltinMethodCall(from: SemanticType, methodName: String, params: List<SemanticType>): SemanticType? {
            // All builtin methods here take no extra parameters.
            if (params.isNotEmpty()) throw CompileError("Builtin method '$methodName' expects no parameters; got $params")

            // Helper to unwrap one layer of reference, returning inner type and mutability.
            fun unwrapRef(t: SemanticType): Pair<SemanticType, Boolean?> {
                return when (t) {
                    is SemanticType.ReferenceType -> Pair(t.type.getOrNull() ?: return Pair(t, null), t.isMutable.getOrNull())
                    else -> Pair(t, null)
                }
            }

            val (base, mut) = unwrapRef(from)

            return when (methodName) {
                // u32/usize.to_string() -> String
                "to_string" -> when (base) {
                    is SemanticType.U32Type, is SemanticType.USizeType -> SemanticType.StringType
                    else -> null
                }

                // String.as_str(&self) -> &str
                "as_str" -> when (base) {
                    is SemanticType.StringType -> SemanticType.RefStrType
                    else -> null
                }

                // String.as_mut_str(&mut self) -> &mut str
                "as_mut_str" -> when (from) {
                    is SemanticType.ReferenceType -> {
                        val inner = from.type.getOrNull() ?: return null
                        val isMut = from.isMutable.getOrNull() ?: return null
                        if (inner is SemanticType.StringType && isMut) SemanticType.ReferenceType(
                            type = rusty.core.utils.Slot(SemanticType.StringType),
                            isMutable = rusty.core.utils.Slot(true)
                        ) else null
                    }
                    else -> null
                }

                // len() -> usize for arrays and strings and their references
                "len" -> when (base) {
                    is SemanticType.ArrayType -> SemanticType.USizeType
                    is SemanticType.StringType -> SemanticType.USizeType
                    else -> null
                }

                else -> null
            }
        }

        // ------- Type-level helpers mirroring value-level checks -------
        private fun isSignedConcreteType(t: SemanticType) = t is SemanticType.I32Type || t is SemanticType.ISizeType
        private fun isUnsignedConcreteType(t: SemanticType) = t is SemanticType.U32Type || t is SemanticType.USizeType
        private fun isAnySignedType(t: SemanticType) = t is SemanticType.AnySignedIntType
        private fun isAnyIntType(t: SemanticType) = t is SemanticType.AnyIntType
        private fun isIntType(t: SemanticType) =
            isSignedConcreteType(t) || isUnsignedConcreteType(t) || isAnySignedType(t) || isAnyIntType(t)

        private fun requireSameOrAbstractForSignedTypes(left: SemanticType, right: SemanticType, opName: String) {
            val ok = when (left) {
                is SemanticType.I32Type -> right is SemanticType.I32Type || isAnyIntType(right) || isAnySignedType(right)
                is SemanticType.ISizeType -> right is SemanticType.ISizeType || isAnyIntType(right) || isAnySignedType(
                    right
                )

                is SemanticType.AnySignedIntType -> right is SemanticType.I32Type || right is SemanticType.ISizeType || isAnySignedType(
                    right
                )

                else -> false
            }
            if (!ok) throw CompileError("Cannot $opName $left and $right")
        }

        private fun requireSameOrAbstractForUnsignedTypes(left: SemanticType, right: SemanticType, opName: String) {
            val ok = when (left) {
                is SemanticType.U32Type -> right is SemanticType.U32Type || isAnyIntType(right)
                is SemanticType.USizeType -> right is SemanticType.USizeType || isAnyIntType(right)
                else -> false
            }
            if (!ok) throw CompileError("Cannot $opName $left and $right")
        }

        private fun intArithmeticType(left: SemanticType, right: SemanticType, opName: String): SemanticType {
            return when (left) {
                is SemanticType.I32Type -> {
                    requireSameOrAbstractForSignedTypes(left, right, opName); SemanticType.I32Type
                }

                is SemanticType.ISizeType -> {
                    requireSameOrAbstractForSignedTypes(left, right, opName); SemanticType.ISizeType
                }

                is SemanticType.U32Type -> {
                    requireSameOrAbstractForUnsignedTypes(left, right, opName); SemanticType.U32Type
                }

                is SemanticType.USizeType -> {
                    requireSameOrAbstractForUnsignedTypes(left, right, opName); SemanticType.USizeType
                }

                is SemanticType.AnySignedIntType -> {
                    requireSameOrAbstractForSignedTypes(left, right, opName)
                    when (right) {
                        is SemanticType.I32Type -> SemanticType.I32Type
                        is SemanticType.ISizeType -> SemanticType.ISizeType
                        is SemanticType.AnySignedIntType -> SemanticType.AnySignedIntType
                        is SemanticType.AnyIntType -> SemanticType.AnySignedIntType
                        else -> throw CompileError("Cannot $opName AnySignedInt and $right")
                    }
                }

                is SemanticType.AnyIntType -> when (right) {
                    is SemanticType.I32Type -> SemanticType.I32Type
                    is SemanticType.ISizeType -> SemanticType.ISizeType
                    is SemanticType.U32Type -> SemanticType.U32Type
                    is SemanticType.USizeType -> SemanticType.USizeType
                    is SemanticType.AnySignedIntType -> SemanticType.AnySignedIntType
                    is SemanticType.AnyIntType -> SemanticType.AnyIntType
                    else -> throw CompileError("Cannot $opName AnyInt and $right")
                }

                else -> throw CompileError("Cannot $opName $left and $right")
            }
        }

        private fun intCompareType(left: SemanticType, right: SemanticType, opName: String) {
            when (left) {
                is SemanticType.I32Type -> requireSameOrAbstractForSignedTypes(left, right, opName)
                is SemanticType.ISizeType -> requireSameOrAbstractForSignedTypes(left, right, opName)
                is SemanticType.U32Type -> requireSameOrAbstractForUnsignedTypes(left, right, opName)
                is SemanticType.USizeType -> requireSameOrAbstractForUnsignedTypes(left, right, opName)
                is SemanticType.AnySignedIntType -> requireSameOrAbstractForSignedTypes(left, right, opName)
                is SemanticType.AnyIntType -> {
                    if (!isIntType(right)) throw CompileError("Cannot $opName AnyInt and $right")
                }

                else -> throw CompileError("Cannot $opName $left and $right")
            }
        }

        private fun intOrBoolEqType(left: SemanticType, right: SemanticType): SemanticType {
            // bool == bool
            if (left is SemanticType.BoolType && right is SemanticType.BoolType) return SemanticType.BoolType
            // char == char
            if (left is SemanticType.CharType && right is SemanticType.CharType) return SemanticType.BoolType
            // string == string (both str and cstr separately)
            if (left is SemanticType.StringType && right is SemanticType.StringType) return SemanticType.BoolType
            if (left is SemanticType.CStringType && right is SemanticType.CStringType) return SemanticType.BoolType

            // Integer families
            return when (left) {
                is SemanticType.I32Type -> {
                    requireSameOrAbstractForSignedTypes(left, right, "compare"); SemanticType.BoolType
                }

                is SemanticType.ISizeType -> {
                    requireSameOrAbstractForSignedTypes(left, right, "compare"); SemanticType.BoolType
                }

                is SemanticType.U32Type -> {
                    requireSameOrAbstractForUnsignedTypes(left, right, "compare"); SemanticType.BoolType
                }

                is SemanticType.USizeType -> {
                    requireSameOrAbstractForUnsignedTypes(left, right, "compare"); SemanticType.BoolType
                }

                is SemanticType.AnySignedIntType -> {
                    requireSameOrAbstractForSignedTypes(left, right, "compare"); SemanticType.BoolType
                }

                is SemanticType.AnyIntType -> {
                    if (!isIntType(right)) throw CompileError("Cannot compare AnyInt and $right"); SemanticType.BoolType
                }

                else -> throw CompileError("Cannot compare $left and $right")
            }
        }

        private fun isSignedConcrete(v: SemanticValue) = v is SemanticValue.I32Value || v is SemanticValue.ISizeValue
        private fun isUnsignedConcrete(v: SemanticValue) = v is SemanticValue.U32Value || v is SemanticValue.USizeValue
        private fun isAnySigned(v: SemanticValue) = v is SemanticValue.AnySignedIntValue
        private fun isAnyInt(v: SemanticValue) = v is SemanticValue.AnyIntValue

        private fun requireSameOrAbstractForSigned(left: SemanticValue, right: SemanticValue, opName: String) {
            val ok = when (left) {
                is SemanticValue.I32Value -> right is SemanticValue.I32Value || isAnyInt(right) || isAnySigned(right)
                is SemanticValue.ISizeValue -> right is SemanticValue.ISizeValue || isAnyInt(right) || isAnySigned(right)
                is SemanticValue.AnySignedIntValue -> right is SemanticValue.I32Value || right is SemanticValue.ISizeValue || isAnySigned(
                    right
                )

                else -> false
            }
            if (!ok) throw CompileError("Cannot $opName ${left::class.simpleName} and ${right::class.simpleName}")
        }

        private fun requireSameOrAbstractForUnsigned(left: SemanticValue, right: SemanticValue, opName: String) {
            // Allow: U32 with (U32|AnyInt), USize with (USize|AnyInt)
            val ok = when (left) {
                is SemanticValue.U32Value -> right is SemanticValue.U32Value || isAnyInt(right)
                is SemanticValue.USizeValue -> right is SemanticValue.USizeValue || isAnyInt(right)
                else -> false
            }
            if (!ok) throw CompileError("Cannot $opName ${left::class.simpleName} and ${right::class.simpleName}")
        }

        private fun toSignedInt(v: SemanticValue): Int = when (v) {
            is SemanticValue.I32Value -> v.value
            is SemanticValue.ISizeValue -> v.value
            is SemanticValue.AnyIntValue -> v.value
            is SemanticValue.AnySignedIntValue -> v.value
            else -> throw CompileError("Expected signed integer, got ${v::class.simpleName}")
        }

        private fun toUnsignedInt(v: SemanticValue): UInt = when (v) {
            is SemanticValue.U32Value -> v.value
            is SemanticValue.USizeValue -> v.value
            is SemanticValue.AnyIntValue -> v.value.toUInt()
            else -> throw CompileError("Expected unsigned integer, got ${v::class.simpleName}")
        }

        private fun intArithmetic(
            left: SemanticValue,
            right: SemanticValue,
            opSigned: (Int, Int) -> Int,
            opUnsigned: (UInt, UInt) -> UInt,
        ): SemanticValue {
            return when (left) {
                is SemanticValue.I32Value -> {
                    requireSameOrAbstractForSigned(left, right, "operate")
                    val a = left.value
                    val b = toSignedInt(right)
                    SemanticValue.I32Value(opSigned(a, b))
                }

                is SemanticValue.ISizeValue -> {
                    requireSameOrAbstractForSigned(left, right, "operate")
                    val a = left.value
                    val b = toSignedInt(right)
                    SemanticValue.ISizeValue(opSigned(a, b))
                }

                is SemanticValue.U32Value -> {
                    requireSameOrAbstractForUnsigned(left, right, "operate")
                    val a = left.value
                    val b = toUnsignedInt(right)
                    SemanticValue.U32Value(opUnsigned(a, b))
                }

                is SemanticValue.USizeValue -> {
                    requireSameOrAbstractForUnsigned(left, right, "operate")
                    val a = left.value
                    val b = toUnsignedInt(right)
                    SemanticValue.USizeValue(opUnsigned(a, b))
                }

                is SemanticValue.AnySignedIntValue -> {
                    requireSameOrAbstractForSigned(left, right, "operate")
                    val a = left.value
                    when (right) {
                        is SemanticValue.I32Value -> SemanticValue.I32Value(opSigned(a, right.value))
                        is SemanticValue.ISizeValue -> SemanticValue.ISizeValue(opSigned(a, right.value))
                        is SemanticValue.AnySignedIntValue -> SemanticValue.AnySignedIntValue(opSigned(a, right.value))
                        is SemanticValue.AnyIntValue -> SemanticValue.AnySignedIntValue(opSigned(a, right.value))
                        else -> throw CompileError("Cannot operate AnySignedInt and ${right::class.simpleName}")
                    }
                }

                is SemanticValue.AnyIntValue -> {
                    val a = left.value
                    when (right) {
                        is SemanticValue.I32Value -> SemanticValue.I32Value(opSigned(a, right.value))
                        is SemanticValue.ISizeValue -> SemanticValue.ISizeValue(opSigned(a, right.value))
                        is SemanticValue.U32Value -> SemanticValue.U32Value(opUnsigned(a.toUInt(), right.value))
                        is SemanticValue.USizeValue -> SemanticValue.USizeValue(opUnsigned(a.toUInt(), right.value))
                        is SemanticValue.AnySignedIntValue -> SemanticValue.AnySignedIntValue(opSigned(a, right.value))
                        is SemanticValue.AnyIntValue -> SemanticValue.AnyIntValue(opSigned(a, right.value))
                        else -> throw CompileError("Cannot operate AnyInt and ${right::class.simpleName}")
                    }
                }

                else -> throw CompileError("Cannot operate ${left::class.simpleName} and ${right::class.simpleName}")
            }
        }

        private fun intCompare(
            left: SemanticValue,
            right: SemanticValue,
            cmpSigned: (Int, Int) -> Boolean,
            cmpUnsigned: (UInt, UInt) -> Boolean,
        ): SemanticValue.BoolValue {
            return when (left) {
                is SemanticValue.I32Value -> {
                    requireSameOrAbstractForSigned(left, right, "compare")
                    SemanticValue.BoolValue(cmpSigned(left.value, toSignedInt(right)))
                }

                is SemanticValue.ISizeValue -> {
                    requireSameOrAbstractForSigned(left, right, "compare")
                    SemanticValue.BoolValue(cmpSigned(left.value, toSignedInt(right)))
                }

                is SemanticValue.U32Value -> {
                    requireSameOrAbstractForUnsigned(left, right, "compare")
                    SemanticValue.BoolValue(cmpUnsigned(left.value, toUnsignedInt(right)))
                }

                is SemanticValue.USizeValue -> {
                    requireSameOrAbstractForUnsigned(left, right, "compare")
                    SemanticValue.BoolValue(cmpUnsigned(left.value, toUnsignedInt(right)))
                }

                is SemanticValue.AnySignedIntValue -> {
                    requireSameOrAbstractForSigned(left, right, "compare")
                    val a = left.value
                    val b = when (right) {
                        is SemanticValue.I32Value -> right.value
                        is SemanticValue.ISizeValue -> right.value
                        is SemanticValue.AnySignedIntValue -> right.value
                        is SemanticValue.AnyIntValue -> right.value
                        else -> throw CompileError("Cannot compare AnySignedInt and ${right::class.simpleName}")
                    }
                    SemanticValue.BoolValue(cmpSigned(a, b))
                }

                is SemanticValue.AnyIntValue -> {
                    val a = left.value
                    val res = when (right) {
                        is SemanticValue.I32Value -> cmpSigned(a, right.value)
                        is SemanticValue.ISizeValue -> cmpSigned(a, right.value)
                        is SemanticValue.U32Value -> cmpUnsigned(a.toUInt(), right.value)
                        is SemanticValue.USizeValue -> cmpUnsigned(a.toUInt(), right.value)
                        is SemanticValue.AnySignedIntValue -> cmpSigned(a, right.value)
                        is SemanticValue.AnyIntValue -> cmpSigned(a, right.value)
                        else -> throw CompileError("Cannot compare AnyInt and ${right::class.simpleName}")
                    }
                    SemanticValue.BoolValue(res)
                }

                else -> throw CompileError("Cannot compare ${left::class.simpleName} and ${right::class.simpleName}")
            }
        }

        // Equality for ints and bools/chars/strings
        private fun intOrBoolEq(left: SemanticValue, right: SemanticValue, eq: Boolean): SemanticValue.BoolValue {
            if (left is SemanticValue.BoolValue && right is SemanticValue.BoolValue) {
                return SemanticValue.BoolValue(if (eq) left.value == right.value else left.value != right.value)
            }
            // Handle char
            if (left is SemanticValue.CharValue && right is SemanticValue.CharValue) {
                return SemanticValue.BoolValue(if (eq) left.value == right.value else left.value != right.value)
            }
            // Handle strings (both String and CString separately, no cross-compare)
            if (left is SemanticValue.StringValue && right is SemanticValue.StringValue) {
                return SemanticValue.BoolValue(if (eq) left.value == right.value else left.value != right.value)
            }
            if (left is SemanticValue.CStringValue && right is SemanticValue.CStringValue) {
                return SemanticValue.BoolValue(if (eq) left.value == right.value else left.value != right.value)
            }

            val res = when (left) {
                is SemanticValue.I32Value -> {
                    requireSameOrAbstractForSigned(left, right, "compare")
                    left.value == toSignedInt(right)
                }

                is SemanticValue.ISizeValue -> {
                    requireSameOrAbstractForSigned(left, right, "compare")
                    left.value == toSignedInt(right)
                }

                is SemanticValue.U32Value -> {
                    requireSameOrAbstractForUnsigned(left, right, "compare")
                    left.value == toUnsignedInt(right)
                }

                is SemanticValue.USizeValue -> {
                    requireSameOrAbstractForUnsigned(left, right, "compare")
                    left.value == toUnsignedInt(right)
                }

                is SemanticValue.AnySignedIntValue -> {
                    requireSameOrAbstractForSigned(left, right, "compare")
                    val b = when (right) {
                        is SemanticValue.I32Value -> right.value
                        is SemanticValue.ISizeValue -> right.value
                        is SemanticValue.AnySignedIntValue -> right.value
                        is SemanticValue.AnyIntValue -> right.value
                        else -> throw CompileError("Cannot compare AnySignedInt and ${right::class.simpleName}")
                    }
                    left.value == b
                }

                is SemanticValue.AnyIntValue -> {
                    when (right) {
                        is SemanticValue.I32Value -> left.value == right.value
                        is SemanticValue.ISizeValue -> left.value == right.value
                        is SemanticValue.U32Value -> left.value.toUInt() == right.value
                        is SemanticValue.USizeValue -> left.value.toUInt() == right.value
                        is SemanticValue.AnySignedIntValue -> left.value == right.value
                        is SemanticValue.AnyIntValue -> left.value == right.value
                        else -> throw CompileError("Cannot compare AnyInt and ${right::class.simpleName}")
                    }
                }

                else -> throw CompileError("Cannot compare ${left::class.simpleName} and ${right::class.simpleName}")
            }
            return SemanticValue.BoolValue(if (eq) res else !res)
        }

        private fun boolLogic(
            left: SemanticValue,
            right: SemanticValue,
            op: (Boolean, Boolean) -> Boolean,
        ): SemanticValue.BoolValue {
            if (left is SemanticValue.BoolValue && right is SemanticValue.BoolValue) {
                return SemanticValue.BoolValue(op(left.value, right.value))
            }
            throw CompileError("Logical operation requires booleans, got ${left::class.simpleName} and ${right::class.simpleName}")
        }

        private fun intBitwise(
            left: SemanticValue,
            right: SemanticValue,
            opSigned: (Int, Int) -> Int,
            opUnsigned: (UInt, UInt) -> UInt,
        ): SemanticValue {
            return intArithmetic(left, right, opSigned, opUnsigned) // same type resolution, different ops
        }

        private fun intShiftLeft(left: SemanticValue, right: SemanticValue): SemanticValue {
            val shift = toShiftAmount(right)
            return when (left) {
                is SemanticValue.I32Value -> SemanticValue.I32Value(left.value shl shift)
                is SemanticValue.ISizeValue -> SemanticValue.ISizeValue(left.value shl shift)
                is SemanticValue.U32Value -> SemanticValue.U32Value(left.value shl shift)
                is SemanticValue.USizeValue -> SemanticValue.USizeValue(left.value shl shift)
                is SemanticValue.AnySignedIntValue -> SemanticValue.AnySignedIntValue(left.value shl shift)
                is SemanticValue.AnyIntValue -> SemanticValue.AnyIntValue(left.value shl shift)
                else -> throw CompileError("Cannot shift ${left::class.simpleName}")
            }
        }

        private fun intShiftRight(left: SemanticValue, right: SemanticValue): SemanticValue {
            val shift = toShiftAmount(right)
            return when (left) {
                is SemanticValue.I32Value -> SemanticValue.I32Value(left.value shr shift)
                is SemanticValue.ISizeValue -> SemanticValue.ISizeValue(left.value shr shift)
                is SemanticValue.U32Value -> SemanticValue.U32Value(left.value shr shift)
                is SemanticValue.USizeValue -> SemanticValue.USizeValue(left.value shr shift)
                is SemanticValue.AnySignedIntValue -> SemanticValue.AnySignedIntValue(left.value shr shift)
                is SemanticValue.AnyIntValue -> SemanticValue.AnyIntValue(left.value shr shift)
                else -> throw CompileError("Cannot shift ${left::class.simpleName}")
            }
        }

        private fun toShiftAmount(v: SemanticValue): Int = when (v) {
            is SemanticValue.I32Value -> v.value
            is SemanticValue.ISizeValue -> v.value
            is SemanticValue.AnySignedIntValue -> v.value
            is SemanticValue.AnyIntValue -> v.value
            is SemanticValue.U32Value -> v.value.toInt()
            is SemanticValue.USizeValue -> v.value.toInt()
            else -> throw CompileError("Shift amount must be an integer, got ${v::class.simpleName}")
        }

        private fun unaryPlus(v: SemanticValue): SemanticValue = when (v) {
            is SemanticValue.I32Value,
            is SemanticValue.U32Value,
            is SemanticValue.ISizeValue,
            is SemanticValue.USizeValue,
            is SemanticValue.AnyIntValue,
            is SemanticValue.AnySignedIntValue -> v

            else -> throw CompileError("Unary plus not supported for ${v::class.simpleName}")
        }

        private fun unaryMinus(v: SemanticValue): SemanticValue = when (v) {
            is SemanticValue.I32Value -> SemanticValue.I32Value(-v.value)
            is SemanticValue.ISizeValue -> SemanticValue.ISizeValue(-v.value)
            is SemanticValue.AnyIntValue -> SemanticValue.AnySignedIntValue(-v.value)
            is SemanticValue.AnySignedIntValue -> SemanticValue.AnySignedIntValue(-v.value)
            else -> throw CompileError("Unary minus not supported for ${v::class.simpleName}")
        }

        private fun unaryNot(v: SemanticValue): SemanticValue = when (v) {
            is SemanticValue.BoolValue -> SemanticValue.BoolValue(!v.value)
            is SemanticValue.I32Value -> SemanticValue.I32Value(v.value.inv())
            is SemanticValue.ISizeValue -> SemanticValue.ISizeValue(v.value.inv())
            is SemanticValue.U32Value -> SemanticValue.U32Value(v.value.inv())
            is SemanticValue.USizeValue -> SemanticValue.USizeValue(v.value.inv())
            is SemanticValue.AnyIntValue -> SemanticValue.AnyIntValue(v.value.inv())
            is SemanticValue.AnySignedIntValue -> SemanticValue.AnySignedIntValue(v.value.inv())
            else -> throw CompileError("Unary ! not supported for ${v::class.simpleName}")
        }
    }
}