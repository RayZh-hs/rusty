# IR Generation Design

## IR Version Overview

The IR system embraces the new simplified `ptr` approach, without pointer type distinctions. Use this system throughout the IR generation phase.

## Type System Overview

The `SemanticType` system has a corresponding IR type system:
- String types are all represented as pointers to i8 (`ptr`).
- Other primitive types are cast to integers:
    - I32, U32, ISize, USize -> `i32`
    - Bool -> `i1`
    - Char -> `i8`
- Enums are represented as `i32` (discriminant only, C++ style).
- Structs use the llvm types definition.
- Arrays follow the llvm array type definition.
- Reference types are represented as pointers (`ptr`) to the values.
- Other types (Unit Type, Never Type) are padded with `i8`, with inherent value 0.
    -> This is to ensure that structs with unit fields are well-defined, and that unit types can be passed around. We assume that it will be optimized away later in the compilation process.
- Traits have been removed.

All structs are defined globally as `types` in llvm-ir at the beginning. If a struct type is empty, it is filled with a single `i8` field to ensure well-definedness.

When initializing arrays, use the prelude function `aux.func.memfill` to fill in arrays. Never manually fill in them element by element, which leads to long and unreadable ir code.

## Naming Conventions

The global naming convention for values is `<holder>.<type>.<name>(.<serial>)`.

The serial is calculated by piping the name through a Renamer provided by the LLVM library, and only for variables.

Holders can be:
- `user`, when the value is explicitly defined by the user.
- `prelude`, when the value is defined in the prelude.
- `aux`, special temporary values specified in the documentation. It is named to facilitate debugging.

Types can be:
- `struct`, for struct types.
- `func`, for functions.
- `var`, for variables.
- `block`, for basic blocks.

Constants are evaluated inline and do not have corresponding names.

Temp values should be declared by using null for the name param. This will generate anonymous variables instead of named ones.

### General Guidelines

All names should be cached in the IR Context for retrieval to handle renaming elegantly. To adhere to the SSA form, so some values need to be renamed, which should be handled by the Renamer utility, provided by the LLVM package. These include:
- Basic Blocks;
- User Function Params and Let Variables;
- Temporary Variables created during expression evaluation;

The `clear(baseName: String)` method of the Renamer can be called to reset the serial number for a specific base name, for example when entering a new function scope.

### Basic Block Names

Basic blocks take the form `aux.block.<serial>`, where the serial number starts from 0 for each function. Use the Renamer to handle serial generation.

### Function Names

Functions are either defined or part of an implementation. Since we do not have traits any longer, we assume the following conventions:

- A function defined in an `impl` block for `x` is named `user.func.x.<function_name>`.
- A function defined outside of an `impl` block is named `user.func.<function_name>`.

If a function is defined in another function, use `$` to separate them. Say:

```
impl X {
    fn outer() {
        fn inner() {}
    }
}
```

Then `inner` is named `user.func.X.outer$inner`. This should be unique, so renaming is not needed.

### Function Parameters and Variables

Two optional params are prepended to the function signature. They are unique so are not renamed:

- `ptr aux.var.self` - for functions in `impl` blocks, the self parameter
- `ptr aux.var.ret` - for non-integral returning functions, the return value pointer

If a function returns unit (mapped to i8), integers or chars directly, the return value pointer is not added. Otherwise (e.g. arrays, structs, strings), the return value pointer is added so that the function can write the return value to the provided stack location, ensuring that it does not generate a dangling pointer.

User-defined parameters and let variables are named as `user.var.<name>.<serial>`, with serial generated by the Renamer.

For temporary variables created:
- If the variable is generated to hold the value of a block expression, it should be named `aux.var.blockret.<serial>`.
- If the variable is generated to hold intermediate results in the calculation process, put null in the name so that it is anonymous. The LLVM package will handle renaming automatically.

## Function Generation Guide

### Blocks

Blocks in rust are handled as basic blocks in LLVM IR that modify an aux value (corresponding to the trailing expression's value). For example:

```
let a = {
    if (b > 0) {
        b;
    } else {
        0
    }
};
```

Translates to something like:

```
define i32 @func(...) {
aux.block.0:
    %aux.var.blockret.0 = alloca i32
    br label %aux.block.4
    %cond = icmp sgt i32 %user.var.b.0, 0
    br i1 %cond, label %aux.block.1, label %aux.block.2

aux.block.1:
    ; [line:column] block then
    store i32 %user.var.b.0, i32* %aux.var.blockret.0
    br label %aux.block.3

aux.block.2:
    ; [line:column] block else
    store i32 0, i32* %aux.var.blockret.0
    br label %aux.block.3

aux.block.3:
    ; [line:column] block end-if
    %user.var.a.0 = load i32, i32* %aux.var.blockret.0
    ; after
}
```

### Prelude Management Tools

In the prelude phase, you will find the following aux functions:

```
define void @aux.func.memfill(ptr %dest, ptr %src, i32 %elsize, i32 %elcount) {
    ; esize comes in bytes, the number of bytes to view as a whole
    ; memcpy is memfill with elcount = 1
    call void @__c_memfill(ptr noundef %dest, ptr noundef %src, i32 noundef %elsize, i32 noundef %elcount)
    ret void
}
define void @aux.func.itoa(i32 %value, ptr %out.ptr) {
    call void @__c_itoa(i32 noundef %value, ptr noundef %out.ptr)
    ret void
}
```

Use memfill to copy memory from one location to another for many times. When initializing arrays, use this to fill the array with a specific value. You can also use it to copy structs and arrays.

You can implement integer to string conversion by calling `aux.func.itoa`.

### Getting the Size of Types

Use ptrtoint to obtain the size of types at runtime. For example:

```
%MyStruct = type { i32, i8, i32 }

define i32 @get_struct_size() {
    ; 1. Create a pointer to the imaginary element at index 1 starting from null
    ;    (Mathematically: 0 + 1 * sizeof(%MyStruct))
    %size_ptr = getelementptr %MyStruct, %MyStruct* null, i32 1

    ; 2. Cast that pointer to an integer to get the byte value
    %size_bytes = ptrtoint %MyStruct* %size_ptr to i32

    ret i32 %size_bytes
}
```

At the beginning of the ir generation phase, after all the struct types are defined, generate functions:

```
define i32 @aux.func.sizeof.<StructName>() {
    ; body as above
}
```

And call these functions whenever you need to get the size of a struct type. This can be useful when you wish to figure out size for memfill. Array sizes are size * element_size, which can be calculated directly.

## Comments

The LLVM package supports comments. Add comments:
- For each basic block, add a full-line comment at its beginning:
    ```
    ; [line:column] block then (or else, end, etc.)
    ```
- For each let statement, add an inline comment:
    ```
    ; [line:column] let <variable-name>
    ```
