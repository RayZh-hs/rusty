# IR Generation Design

## IR Version Overview

The IR system embraces the new simplified `ptr` approach, without pointer type distinctions. Use this system throughout the IR generation phase.

## Type System Overview

The `SemanticType` system has a corresponding IR type system:
- String types are all represented as pointers to i8 (`ptr`).
- Other primitive types are cast to integers:
    - I32, U32, ISize, USize -> `i32`
    - Bool -> `i1`
    - Char -> `i8`
- Enums are represented as `i32` (discriminant only, C++ style).
- Compound types are represented as pointers (`ptr`).
- Other types (Unit Type, Never Type) are padded with `i8`, with inherent value 0.
    -> This is to ensure that structs with unit fields are well-defined, and that unit types can be passed around. We assume that it will be optimized away later in the compilation process.
- Traits have been removed.

All structs are defined globally as `types` in llvm-ir at the beginning. If a struct type is empty, it is filled with a single `i8` field to ensure well-definedness.

## Naming Conventions

The global naming convention for values is `<holder>.<type>.<name>(.<serial>)`.

The serial is calculated by piping the name through a Renamer provided by the LLVM library, and only for variables.

Holders can be:
- `user`, when the value is explicitly defined by the user.
- `prelude`, when the value is defined in the prelude.
- `aux`, special temporary values specified in the documentation. It is named to facilitate debugging.

Types can be:
- `struct`, for struct types.
- `func`, for functions.
- `var`, for variables.
- `block`, for basic blocks.

Constants are evaluated inline and do not have corresponding names.

Temp values should be declared by using null for the name param. This will generate anonymous variables instead of named ones.

### General Guidelines

All names should be cached in the IR Context for retrieval to handle renaming elegantly. To adhere to the SSA form, so some values need to be renamed, which should be handled by the Renamer utility, provided by the LLVM package. These include:
- Basic Blocks;
- User Function Params and Let Variables;
- Temporary Variables created during expression evaluation;

The `clear(baseName: String)` method of the Renamer can be called to reset the serial number for a specific base name, for example when entering a new function scope.

### Basic Block Names

Basic blocks take the form `aux.block.<serial>`, where the serial number starts from 0 for each function. Use the Renamer to handle serial generation.

### Function Names

Functions are either defined or part of an implementation. Since we do not have traits any longer, we assume the following conventions:

- A function defined in an `impl` block for `x` is named `user.func.x.<function_name>`.
- A function defined outside of an `impl` block is named `user.func.<function_name>`.

If a function is defined in another function, use `$` to separate them. Say:

```
impl X {
    fn outer() {
        fn inner() {}
    }
}
```

Then `inner` is named `user.func.X.outer$inner`. This should be unique, so renaming is not needed.

### Function Parameters and Variables

Two optional params are prepended to the function signature. They are unique so are not renamed:

- `ptr aux.var.self` - for functions in `impl` blocks, the self parameter
- `ptr aux.var.ret` - for non-unit returning functions, the return value pointer

If a function returns unit (mapped to i8), integers or chars directly, the return value pointer is not added.

User-defined parameters and let variables are named as `user.var.<name>.<serial>`, with serial generated by the Renamer.

For temporary variables created:
- If the variable is generated to hold the value of a block expression, it should be named `aux.var.blockret.<serial>`.
- If the variable is generated to hold intermediate results in the calculation process, put null in the name so that it is anonymous. The LLVM package will handle renaming automatically.

## Function Generation Guide

### Blocks

Blocks in rust are handled as basic blocks in LLVM IR that modify an aux value (corresponding to the trailing expression's value). For example:

```
let a = {
    if (b > 0) {
        b;
    } else {
        0
    }
};
```

Translates to something like:

```
define i32 @func(...) {
aux.block.0:
    %aux.var.blockret.0 = alloca i32
    br label %aux.block.4
    %cond = icmp sgt i32 %user.var.b.0, 0
    br i1 %cond, label %aux.block.1, label %aux.block.2

aux.block.1: ; then-block
    store i32 %user.var.b.0, i32* %aux.var.blockret.0
    br label %aux.block.3

aux.block.2: ; else-block
    store i32 0, i32* %aux.var.blockret.0
    br label %aux.block.3

aux.block.3: ; end-if
    %user.var.a.0 = load i32, i32* %aux.var.blockret.0
    ; after
}
```

## Comments

The LLVM package supports comments. Add comments:
- For each basic block, add a full-line comment at its beginning:
    ```
    ; [line:column] then-block (or else-block, end-if, etc.)
    ```
- For each let statement, add an inline comment:
    ```
    ; [line:column] let <variable-name>
    ```
